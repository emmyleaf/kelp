/* based on docking_bindings.rs from imgui-sys-0.10.0
 * which was automatically generated by rust-bindgen 0.63.0
 * edits made:
 * - use std::ffi c types
 * - remove function declarations
 * - allow dead_code */

#![allow(nonstandard_style, clippy::all, dead_code)]

use std::ffi::{c_char, c_int, c_long, c_longlong, c_schar, c_short, c_uchar, c_uint, c_ulonglong, c_ushort, c_void};

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type __off_t = c_long;
pub type __off64_t = c_long;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _IO_FILE {
    pub _flags: c_int,
    pub _IO_read_ptr: *mut c_char,
    pub _IO_read_end: *mut c_char,
    pub _IO_read_base: *mut c_char,
    pub _IO_write_base: *mut c_char,
    pub _IO_write_ptr: *mut c_char,
    pub _IO_write_end: *mut c_char,
    pub _IO_buf_base: *mut c_char,
    pub _IO_buf_end: *mut c_char,
    pub _IO_save_base: *mut c_char,
    pub _IO_backup_base: *mut c_char,
    pub _IO_save_end: *mut c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: c_int,
    pub _flags2: c_int,
    pub _old_offset: __off_t,
    pub _cur_column: c_ushort,
    pub _vtable_offset: c_schar,
    pub _shortbuf: [c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut c_void,
    pub __pad5: usize,
    pub _mode: c_int,
    pub _unused2: [c_char; 20usize],
}
impl Default for _IO_FILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiDockRequest {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImGuiDockNodeSettings {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_const_charPtr {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut *const c_char,
}
impl Default for ImVector_const_charPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ImGuiCol = c_int;
pub type ImGuiCond = c_int;
pub type ImGuiDataType = c_int;
pub type ImGuiDir = c_int;
pub type ImGuiMouseButton = c_int;
pub type ImGuiMouseCursor = c_int;
pub type ImGuiSortDirection = c_int;
pub type ImGuiStyleVar = c_int;
pub type ImGuiTableBgTarget = c_int;
pub type ImDrawFlags = c_int;
pub type ImDrawListFlags = c_int;
pub type ImFontAtlasFlags = c_int;
pub type ImGuiBackendFlags = c_int;
pub type ImGuiButtonFlags = c_int;
pub type ImGuiColorEditFlags = c_int;
pub type ImGuiConfigFlags = c_int;
pub type ImGuiComboFlags = c_int;
pub type ImGuiDockNodeFlags = c_int;
pub type ImGuiDragDropFlags = c_int;
pub type ImGuiFocusedFlags = c_int;
pub type ImGuiHoveredFlags = c_int;
pub type ImGuiInputTextFlags = c_int;
pub type ImGuiKeyChord = c_int;
pub type ImGuiPopupFlags = c_int;
pub type ImGuiSelectableFlags = c_int;
pub type ImGuiSliderFlags = c_int;
pub type ImGuiTabBarFlags = c_int;
pub type ImGuiTabItemFlags = c_int;
pub type ImGuiTableFlags = c_int;
pub type ImGuiTableColumnFlags = c_int;
pub type ImGuiTableRowFlags = c_int;
pub type ImGuiTreeNodeFlags = c_int;
pub type ImGuiViewportFlags = c_int;
pub type ImGuiWindowFlags = c_int;
pub type ImTextureID = *mut c_void;
pub type ImDrawIdx = c_ushort;
pub type ImGuiID = c_uint;
pub type ImS8 = c_schar;
pub type ImU8 = c_uchar;
pub type ImS16 = c_short;
pub type ImU16 = c_ushort;
pub type ImS32 = c_int;
pub type ImU32 = c_uint;
pub type ImS64 = c_longlong;
pub type ImU64 = c_ulonglong;
pub type ImWchar16 = c_ushort;
pub type ImWchar32 = c_uint;
pub type ImWchar = ImWchar32;
pub type ImGuiInputTextCallback =
    ::core::option::Option<unsafe extern "C" fn(data: *mut ImGuiInputTextCallbackData) -> c_int>;
pub type ImGuiSizeCallback = ::core::option::Option<unsafe extern "C" fn(data: *mut ImGuiSizeCallbackData)>;
pub type ImGuiMemAllocFunc =
    ::core::option::Option<unsafe extern "C" fn(sz: usize, user_data: *mut c_void) -> *mut c_void>;
pub type ImGuiMemFreeFunc = ::core::option::Option<unsafe extern "C" fn(ptr: *mut c_void, user_data: *mut c_void)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImVec2 {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImVec4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
pub const ImGuiWindowFlags_None: ImGuiWindowFlags_ = 0;
pub const ImGuiWindowFlags_NoTitleBar: ImGuiWindowFlags_ = 1;
pub const ImGuiWindowFlags_NoResize: ImGuiWindowFlags_ = 2;
pub const ImGuiWindowFlags_NoMove: ImGuiWindowFlags_ = 4;
pub const ImGuiWindowFlags_NoScrollbar: ImGuiWindowFlags_ = 8;
pub const ImGuiWindowFlags_NoScrollWithMouse: ImGuiWindowFlags_ = 16;
pub const ImGuiWindowFlags_NoCollapse: ImGuiWindowFlags_ = 32;
pub const ImGuiWindowFlags_AlwaysAutoResize: ImGuiWindowFlags_ = 64;
pub const ImGuiWindowFlags_NoBackground: ImGuiWindowFlags_ = 128;
pub const ImGuiWindowFlags_NoSavedSettings: ImGuiWindowFlags_ = 256;
pub const ImGuiWindowFlags_NoMouseInputs: ImGuiWindowFlags_ = 512;
pub const ImGuiWindowFlags_MenuBar: ImGuiWindowFlags_ = 1024;
pub const ImGuiWindowFlags_HorizontalScrollbar: ImGuiWindowFlags_ = 2048;
pub const ImGuiWindowFlags_NoFocusOnAppearing: ImGuiWindowFlags_ = 4096;
pub const ImGuiWindowFlags_NoBringToFrontOnFocus: ImGuiWindowFlags_ = 8192;
pub const ImGuiWindowFlags_AlwaysVerticalScrollbar: ImGuiWindowFlags_ = 16384;
pub const ImGuiWindowFlags_AlwaysHorizontalScrollbar: ImGuiWindowFlags_ = 32768;
pub const ImGuiWindowFlags_AlwaysUseWindowPadding: ImGuiWindowFlags_ = 65536;
pub const ImGuiWindowFlags_NoNavInputs: ImGuiWindowFlags_ = 262144;
pub const ImGuiWindowFlags_NoNavFocus: ImGuiWindowFlags_ = 524288;
pub const ImGuiWindowFlags_UnsavedDocument: ImGuiWindowFlags_ = 1048576;
pub const ImGuiWindowFlags_NoDocking: ImGuiWindowFlags_ = 2097152;
pub const ImGuiWindowFlags_NoNav: ImGuiWindowFlags_ = 786432;
pub const ImGuiWindowFlags_NoDecoration: ImGuiWindowFlags_ = 43;
pub const ImGuiWindowFlags_NoInputs: ImGuiWindowFlags_ = 786944;
pub const ImGuiWindowFlags_NavFlattened: ImGuiWindowFlags_ = 8388608;
pub const ImGuiWindowFlags_ChildWindow: ImGuiWindowFlags_ = 16777216;
pub const ImGuiWindowFlags_Tooltip: ImGuiWindowFlags_ = 33554432;
pub const ImGuiWindowFlags_Popup: ImGuiWindowFlags_ = 67108864;
pub const ImGuiWindowFlags_Modal: ImGuiWindowFlags_ = 134217728;
pub const ImGuiWindowFlags_ChildMenu: ImGuiWindowFlags_ = 268435456;
pub const ImGuiWindowFlags_DockNodeHost: ImGuiWindowFlags_ = 536870912;
pub type ImGuiWindowFlags_ = c_uint;
pub const ImGuiInputTextFlags_None: ImGuiInputTextFlags_ = 0;
pub const ImGuiInputTextFlags_CharsDecimal: ImGuiInputTextFlags_ = 1;
pub const ImGuiInputTextFlags_CharsHexadecimal: ImGuiInputTextFlags_ = 2;
pub const ImGuiInputTextFlags_CharsUppercase: ImGuiInputTextFlags_ = 4;
pub const ImGuiInputTextFlags_CharsNoBlank: ImGuiInputTextFlags_ = 8;
pub const ImGuiInputTextFlags_AutoSelectAll: ImGuiInputTextFlags_ = 16;
pub const ImGuiInputTextFlags_EnterReturnsTrue: ImGuiInputTextFlags_ = 32;
pub const ImGuiInputTextFlags_CallbackCompletion: ImGuiInputTextFlags_ = 64;
pub const ImGuiInputTextFlags_CallbackHistory: ImGuiInputTextFlags_ = 128;
pub const ImGuiInputTextFlags_CallbackAlways: ImGuiInputTextFlags_ = 256;
pub const ImGuiInputTextFlags_CallbackCharFilter: ImGuiInputTextFlags_ = 512;
pub const ImGuiInputTextFlags_AllowTabInput: ImGuiInputTextFlags_ = 1024;
pub const ImGuiInputTextFlags_CtrlEnterForNewLine: ImGuiInputTextFlags_ = 2048;
pub const ImGuiInputTextFlags_NoHorizontalScroll: ImGuiInputTextFlags_ = 4096;
pub const ImGuiInputTextFlags_AlwaysOverwrite: ImGuiInputTextFlags_ = 8192;
pub const ImGuiInputTextFlags_ReadOnly: ImGuiInputTextFlags_ = 16384;
pub const ImGuiInputTextFlags_Password: ImGuiInputTextFlags_ = 32768;
pub const ImGuiInputTextFlags_NoUndoRedo: ImGuiInputTextFlags_ = 65536;
pub const ImGuiInputTextFlags_CharsScientific: ImGuiInputTextFlags_ = 131072;
pub const ImGuiInputTextFlags_CallbackResize: ImGuiInputTextFlags_ = 262144;
pub const ImGuiInputTextFlags_CallbackEdit: ImGuiInputTextFlags_ = 524288;
pub const ImGuiInputTextFlags_EscapeClearsAll: ImGuiInputTextFlags_ = 1048576;
pub type ImGuiInputTextFlags_ = c_uint;
pub const ImGuiTreeNodeFlags_None: ImGuiTreeNodeFlags_ = 0;
pub const ImGuiTreeNodeFlags_Selected: ImGuiTreeNodeFlags_ = 1;
pub const ImGuiTreeNodeFlags_Framed: ImGuiTreeNodeFlags_ = 2;
pub const ImGuiTreeNodeFlags_AllowItemOverlap: ImGuiTreeNodeFlags_ = 4;
pub const ImGuiTreeNodeFlags_NoTreePushOnOpen: ImGuiTreeNodeFlags_ = 8;
pub const ImGuiTreeNodeFlags_NoAutoOpenOnLog: ImGuiTreeNodeFlags_ = 16;
pub const ImGuiTreeNodeFlags_DefaultOpen: ImGuiTreeNodeFlags_ = 32;
pub const ImGuiTreeNodeFlags_OpenOnDoubleClick: ImGuiTreeNodeFlags_ = 64;
pub const ImGuiTreeNodeFlags_OpenOnArrow: ImGuiTreeNodeFlags_ = 128;
pub const ImGuiTreeNodeFlags_Leaf: ImGuiTreeNodeFlags_ = 256;
pub const ImGuiTreeNodeFlags_Bullet: ImGuiTreeNodeFlags_ = 512;
pub const ImGuiTreeNodeFlags_FramePadding: ImGuiTreeNodeFlags_ = 1024;
pub const ImGuiTreeNodeFlags_SpanAvailWidth: ImGuiTreeNodeFlags_ = 2048;
pub const ImGuiTreeNodeFlags_SpanFullWidth: ImGuiTreeNodeFlags_ = 4096;
pub const ImGuiTreeNodeFlags_NavLeftJumpsBackHere: ImGuiTreeNodeFlags_ = 8192;
pub const ImGuiTreeNodeFlags_CollapsingHeader: ImGuiTreeNodeFlags_ = 26;
pub type ImGuiTreeNodeFlags_ = c_uint;
pub const ImGuiPopupFlags_None: ImGuiPopupFlags_ = 0;
pub const ImGuiPopupFlags_MouseButtonLeft: ImGuiPopupFlags_ = 0;
pub const ImGuiPopupFlags_MouseButtonRight: ImGuiPopupFlags_ = 1;
pub const ImGuiPopupFlags_MouseButtonMiddle: ImGuiPopupFlags_ = 2;
pub const ImGuiPopupFlags_MouseButtonMask_: ImGuiPopupFlags_ = 31;
pub const ImGuiPopupFlags_MouseButtonDefault_: ImGuiPopupFlags_ = 1;
pub const ImGuiPopupFlags_NoOpenOverExistingPopup: ImGuiPopupFlags_ = 32;
pub const ImGuiPopupFlags_NoOpenOverItems: ImGuiPopupFlags_ = 64;
pub const ImGuiPopupFlags_AnyPopupId: ImGuiPopupFlags_ = 128;
pub const ImGuiPopupFlags_AnyPopupLevel: ImGuiPopupFlags_ = 256;
pub const ImGuiPopupFlags_AnyPopup: ImGuiPopupFlags_ = 384;
pub type ImGuiPopupFlags_ = c_uint;
pub const ImGuiSelectableFlags_None: ImGuiSelectableFlags_ = 0;
pub const ImGuiSelectableFlags_DontClosePopups: ImGuiSelectableFlags_ = 1;
pub const ImGuiSelectableFlags_SpanAllColumns: ImGuiSelectableFlags_ = 2;
pub const ImGuiSelectableFlags_AllowDoubleClick: ImGuiSelectableFlags_ = 4;
pub const ImGuiSelectableFlags_Disabled: ImGuiSelectableFlags_ = 8;
pub const ImGuiSelectableFlags_AllowItemOverlap: ImGuiSelectableFlags_ = 16;
pub type ImGuiSelectableFlags_ = c_uint;
pub const ImGuiComboFlags_None: ImGuiComboFlags_ = 0;
pub const ImGuiComboFlags_PopupAlignLeft: ImGuiComboFlags_ = 1;
pub const ImGuiComboFlags_HeightSmall: ImGuiComboFlags_ = 2;
pub const ImGuiComboFlags_HeightRegular: ImGuiComboFlags_ = 4;
pub const ImGuiComboFlags_HeightLarge: ImGuiComboFlags_ = 8;
pub const ImGuiComboFlags_HeightLargest: ImGuiComboFlags_ = 16;
pub const ImGuiComboFlags_NoArrowButton: ImGuiComboFlags_ = 32;
pub const ImGuiComboFlags_NoPreview: ImGuiComboFlags_ = 64;
pub const ImGuiComboFlags_HeightMask_: ImGuiComboFlags_ = 30;
pub type ImGuiComboFlags_ = c_uint;
pub const ImGuiTabBarFlags_None: ImGuiTabBarFlags_ = 0;
pub const ImGuiTabBarFlags_Reorderable: ImGuiTabBarFlags_ = 1;
pub const ImGuiTabBarFlags_AutoSelectNewTabs: ImGuiTabBarFlags_ = 2;
pub const ImGuiTabBarFlags_TabListPopupButton: ImGuiTabBarFlags_ = 4;
pub const ImGuiTabBarFlags_NoCloseWithMiddleMouseButton: ImGuiTabBarFlags_ = 8;
pub const ImGuiTabBarFlags_NoTabListScrollingButtons: ImGuiTabBarFlags_ = 16;
pub const ImGuiTabBarFlags_NoTooltip: ImGuiTabBarFlags_ = 32;
pub const ImGuiTabBarFlags_FittingPolicyResizeDown: ImGuiTabBarFlags_ = 64;
pub const ImGuiTabBarFlags_FittingPolicyScroll: ImGuiTabBarFlags_ = 128;
pub const ImGuiTabBarFlags_FittingPolicyMask_: ImGuiTabBarFlags_ = 192;
pub const ImGuiTabBarFlags_FittingPolicyDefault_: ImGuiTabBarFlags_ = 64;
pub type ImGuiTabBarFlags_ = c_uint;
pub const ImGuiTabItemFlags_None: ImGuiTabItemFlags_ = 0;
pub const ImGuiTabItemFlags_UnsavedDocument: ImGuiTabItemFlags_ = 1;
pub const ImGuiTabItemFlags_SetSelected: ImGuiTabItemFlags_ = 2;
pub const ImGuiTabItemFlags_NoCloseWithMiddleMouseButton: ImGuiTabItemFlags_ = 4;
pub const ImGuiTabItemFlags_NoPushId: ImGuiTabItemFlags_ = 8;
pub const ImGuiTabItemFlags_NoTooltip: ImGuiTabItemFlags_ = 16;
pub const ImGuiTabItemFlags_NoReorder: ImGuiTabItemFlags_ = 32;
pub const ImGuiTabItemFlags_Leading: ImGuiTabItemFlags_ = 64;
pub const ImGuiTabItemFlags_Trailing: ImGuiTabItemFlags_ = 128;
pub type ImGuiTabItemFlags_ = c_uint;
pub const ImGuiTableFlags_None: ImGuiTableFlags_ = 0;
pub const ImGuiTableFlags_Resizable: ImGuiTableFlags_ = 1;
pub const ImGuiTableFlags_Reorderable: ImGuiTableFlags_ = 2;
pub const ImGuiTableFlags_Hideable: ImGuiTableFlags_ = 4;
pub const ImGuiTableFlags_Sortable: ImGuiTableFlags_ = 8;
pub const ImGuiTableFlags_NoSavedSettings: ImGuiTableFlags_ = 16;
pub const ImGuiTableFlags_ContextMenuInBody: ImGuiTableFlags_ = 32;
pub const ImGuiTableFlags_RowBg: ImGuiTableFlags_ = 64;
pub const ImGuiTableFlags_BordersInnerH: ImGuiTableFlags_ = 128;
pub const ImGuiTableFlags_BordersOuterH: ImGuiTableFlags_ = 256;
pub const ImGuiTableFlags_BordersInnerV: ImGuiTableFlags_ = 512;
pub const ImGuiTableFlags_BordersOuterV: ImGuiTableFlags_ = 1024;
pub const ImGuiTableFlags_BordersH: ImGuiTableFlags_ = 384;
pub const ImGuiTableFlags_BordersV: ImGuiTableFlags_ = 1536;
pub const ImGuiTableFlags_BordersInner: ImGuiTableFlags_ = 640;
pub const ImGuiTableFlags_BordersOuter: ImGuiTableFlags_ = 1280;
pub const ImGuiTableFlags_Borders: ImGuiTableFlags_ = 1920;
pub const ImGuiTableFlags_NoBordersInBody: ImGuiTableFlags_ = 2048;
pub const ImGuiTableFlags_NoBordersInBodyUntilResize: ImGuiTableFlags_ = 4096;
pub const ImGuiTableFlags_SizingFixedFit: ImGuiTableFlags_ = 8192;
pub const ImGuiTableFlags_SizingFixedSame: ImGuiTableFlags_ = 16384;
pub const ImGuiTableFlags_SizingStretchProp: ImGuiTableFlags_ = 24576;
pub const ImGuiTableFlags_SizingStretchSame: ImGuiTableFlags_ = 32768;
pub const ImGuiTableFlags_NoHostExtendX: ImGuiTableFlags_ = 65536;
pub const ImGuiTableFlags_NoHostExtendY: ImGuiTableFlags_ = 131072;
pub const ImGuiTableFlags_NoKeepColumnsVisible: ImGuiTableFlags_ = 262144;
pub const ImGuiTableFlags_PreciseWidths: ImGuiTableFlags_ = 524288;
pub const ImGuiTableFlags_NoClip: ImGuiTableFlags_ = 1048576;
pub const ImGuiTableFlags_PadOuterX: ImGuiTableFlags_ = 2097152;
pub const ImGuiTableFlags_NoPadOuterX: ImGuiTableFlags_ = 4194304;
pub const ImGuiTableFlags_NoPadInnerX: ImGuiTableFlags_ = 8388608;
pub const ImGuiTableFlags_ScrollX: ImGuiTableFlags_ = 16777216;
pub const ImGuiTableFlags_ScrollY: ImGuiTableFlags_ = 33554432;
pub const ImGuiTableFlags_SortMulti: ImGuiTableFlags_ = 67108864;
pub const ImGuiTableFlags_SortTristate: ImGuiTableFlags_ = 134217728;
pub const ImGuiTableFlags_SizingMask_: ImGuiTableFlags_ = 57344;
pub type ImGuiTableFlags_ = c_uint;
pub const ImGuiTableColumnFlags_None: ImGuiTableColumnFlags_ = 0;
pub const ImGuiTableColumnFlags_Disabled: ImGuiTableColumnFlags_ = 1;
pub const ImGuiTableColumnFlags_DefaultHide: ImGuiTableColumnFlags_ = 2;
pub const ImGuiTableColumnFlags_DefaultSort: ImGuiTableColumnFlags_ = 4;
pub const ImGuiTableColumnFlags_WidthStretch: ImGuiTableColumnFlags_ = 8;
pub const ImGuiTableColumnFlags_WidthFixed: ImGuiTableColumnFlags_ = 16;
pub const ImGuiTableColumnFlags_NoResize: ImGuiTableColumnFlags_ = 32;
pub const ImGuiTableColumnFlags_NoReorder: ImGuiTableColumnFlags_ = 64;
pub const ImGuiTableColumnFlags_NoHide: ImGuiTableColumnFlags_ = 128;
pub const ImGuiTableColumnFlags_NoClip: ImGuiTableColumnFlags_ = 256;
pub const ImGuiTableColumnFlags_NoSort: ImGuiTableColumnFlags_ = 512;
pub const ImGuiTableColumnFlags_NoSortAscending: ImGuiTableColumnFlags_ = 1024;
pub const ImGuiTableColumnFlags_NoSortDescending: ImGuiTableColumnFlags_ = 2048;
pub const ImGuiTableColumnFlags_NoHeaderLabel: ImGuiTableColumnFlags_ = 4096;
pub const ImGuiTableColumnFlags_NoHeaderWidth: ImGuiTableColumnFlags_ = 8192;
pub const ImGuiTableColumnFlags_PreferSortAscending: ImGuiTableColumnFlags_ = 16384;
pub const ImGuiTableColumnFlags_PreferSortDescending: ImGuiTableColumnFlags_ = 32768;
pub const ImGuiTableColumnFlags_IndentEnable: ImGuiTableColumnFlags_ = 65536;
pub const ImGuiTableColumnFlags_IndentDisable: ImGuiTableColumnFlags_ = 131072;
pub const ImGuiTableColumnFlags_IsEnabled: ImGuiTableColumnFlags_ = 16777216;
pub const ImGuiTableColumnFlags_IsVisible: ImGuiTableColumnFlags_ = 33554432;
pub const ImGuiTableColumnFlags_IsSorted: ImGuiTableColumnFlags_ = 67108864;
pub const ImGuiTableColumnFlags_IsHovered: ImGuiTableColumnFlags_ = 134217728;
pub const ImGuiTableColumnFlags_WidthMask_: ImGuiTableColumnFlags_ = 24;
pub const ImGuiTableColumnFlags_IndentMask_: ImGuiTableColumnFlags_ = 196608;
pub const ImGuiTableColumnFlags_StatusMask_: ImGuiTableColumnFlags_ = 251658240;
pub const ImGuiTableColumnFlags_NoDirectResize_: ImGuiTableColumnFlags_ = 1073741824;
pub type ImGuiTableColumnFlags_ = c_uint;
pub const ImGuiTableRowFlags_None: ImGuiTableRowFlags_ = 0;
pub const ImGuiTableRowFlags_Headers: ImGuiTableRowFlags_ = 1;
pub type ImGuiTableRowFlags_ = c_uint;
pub const ImGuiTableBgTarget_None: ImGuiTableBgTarget_ = 0;
pub const ImGuiTableBgTarget_RowBg0: ImGuiTableBgTarget_ = 1;
pub const ImGuiTableBgTarget_RowBg1: ImGuiTableBgTarget_ = 2;
pub const ImGuiTableBgTarget_CellBg: ImGuiTableBgTarget_ = 3;
pub type ImGuiTableBgTarget_ = c_uint;
pub const ImGuiFocusedFlags_None: ImGuiFocusedFlags_ = 0;
pub const ImGuiFocusedFlags_ChildWindows: ImGuiFocusedFlags_ = 1;
pub const ImGuiFocusedFlags_RootWindow: ImGuiFocusedFlags_ = 2;
pub const ImGuiFocusedFlags_AnyWindow: ImGuiFocusedFlags_ = 4;
pub const ImGuiFocusedFlags_NoPopupHierarchy: ImGuiFocusedFlags_ = 8;
pub const ImGuiFocusedFlags_DockHierarchy: ImGuiFocusedFlags_ = 16;
pub const ImGuiFocusedFlags_RootAndChildWindows: ImGuiFocusedFlags_ = 3;
pub type ImGuiFocusedFlags_ = c_uint;
pub const ImGuiHoveredFlags_None: ImGuiHoveredFlags_ = 0;
pub const ImGuiHoveredFlags_ChildWindows: ImGuiHoveredFlags_ = 1;
pub const ImGuiHoveredFlags_RootWindow: ImGuiHoveredFlags_ = 2;
pub const ImGuiHoveredFlags_AnyWindow: ImGuiHoveredFlags_ = 4;
pub const ImGuiHoveredFlags_NoPopupHierarchy: ImGuiHoveredFlags_ = 8;
pub const ImGuiHoveredFlags_DockHierarchy: ImGuiHoveredFlags_ = 16;
pub const ImGuiHoveredFlags_AllowWhenBlockedByPopup: ImGuiHoveredFlags_ = 32;
pub const ImGuiHoveredFlags_AllowWhenBlockedByActiveItem: ImGuiHoveredFlags_ = 128;
pub const ImGuiHoveredFlags_AllowWhenOverlapped: ImGuiHoveredFlags_ = 256;
pub const ImGuiHoveredFlags_AllowWhenDisabled: ImGuiHoveredFlags_ = 512;
pub const ImGuiHoveredFlags_NoNavOverride: ImGuiHoveredFlags_ = 1024;
pub const ImGuiHoveredFlags_RectOnly: ImGuiHoveredFlags_ = 416;
pub const ImGuiHoveredFlags_RootAndChildWindows: ImGuiHoveredFlags_ = 3;
pub const ImGuiHoveredFlags_DelayNormal: ImGuiHoveredFlags_ = 2048;
pub const ImGuiHoveredFlags_DelayShort: ImGuiHoveredFlags_ = 4096;
pub const ImGuiHoveredFlags_NoSharedDelay: ImGuiHoveredFlags_ = 8192;
pub type ImGuiHoveredFlags_ = c_uint;
pub const ImGuiDockNodeFlags_None: ImGuiDockNodeFlags_ = 0;
pub const ImGuiDockNodeFlags_KeepAliveOnly: ImGuiDockNodeFlags_ = 1;
pub const ImGuiDockNodeFlags_NoDockingInCentralNode: ImGuiDockNodeFlags_ = 4;
pub const ImGuiDockNodeFlags_PassthruCentralNode: ImGuiDockNodeFlags_ = 8;
pub const ImGuiDockNodeFlags_NoSplit: ImGuiDockNodeFlags_ = 16;
pub const ImGuiDockNodeFlags_NoResize: ImGuiDockNodeFlags_ = 32;
pub const ImGuiDockNodeFlags_AutoHideTabBar: ImGuiDockNodeFlags_ = 64;
pub type ImGuiDockNodeFlags_ = c_uint;
pub const ImGuiDragDropFlags_None: ImGuiDragDropFlags_ = 0;
pub const ImGuiDragDropFlags_SourceNoPreviewTooltip: ImGuiDragDropFlags_ = 1;
pub const ImGuiDragDropFlags_SourceNoDisableHover: ImGuiDragDropFlags_ = 2;
pub const ImGuiDragDropFlags_SourceNoHoldToOpenOthers: ImGuiDragDropFlags_ = 4;
pub const ImGuiDragDropFlags_SourceAllowNullID: ImGuiDragDropFlags_ = 8;
pub const ImGuiDragDropFlags_SourceExtern: ImGuiDragDropFlags_ = 16;
pub const ImGuiDragDropFlags_SourceAutoExpirePayload: ImGuiDragDropFlags_ = 32;
pub const ImGuiDragDropFlags_AcceptBeforeDelivery: ImGuiDragDropFlags_ = 1024;
pub const ImGuiDragDropFlags_AcceptNoDrawDefaultRect: ImGuiDragDropFlags_ = 2048;
pub const ImGuiDragDropFlags_AcceptNoPreviewTooltip: ImGuiDragDropFlags_ = 4096;
pub const ImGuiDragDropFlags_AcceptPeekOnly: ImGuiDragDropFlags_ = 3072;
pub type ImGuiDragDropFlags_ = c_uint;
pub const ImGuiDataType_S8: ImGuiDataType_ = 0;
pub const ImGuiDataType_U8: ImGuiDataType_ = 1;
pub const ImGuiDataType_S16: ImGuiDataType_ = 2;
pub const ImGuiDataType_U16: ImGuiDataType_ = 3;
pub const ImGuiDataType_S32: ImGuiDataType_ = 4;
pub const ImGuiDataType_U32: ImGuiDataType_ = 5;
pub const ImGuiDataType_S64: ImGuiDataType_ = 6;
pub const ImGuiDataType_U64: ImGuiDataType_ = 7;
pub const ImGuiDataType_Float: ImGuiDataType_ = 8;
pub const ImGuiDataType_Double: ImGuiDataType_ = 9;
pub const ImGuiDataType_COUNT: ImGuiDataType_ = 10;
pub type ImGuiDataType_ = c_uint;
pub const ImGuiDir_None: ImGuiDir_ = -1;
pub const ImGuiDir_Left: ImGuiDir_ = 0;
pub const ImGuiDir_Right: ImGuiDir_ = 1;
pub const ImGuiDir_Up: ImGuiDir_ = 2;
pub const ImGuiDir_Down: ImGuiDir_ = 3;
pub const ImGuiDir_COUNT: ImGuiDir_ = 4;
pub type ImGuiDir_ = c_int;
pub const ImGuiSortDirection_None: ImGuiSortDirection_ = 0;
pub const ImGuiSortDirection_Ascending: ImGuiSortDirection_ = 1;
pub const ImGuiSortDirection_Descending: ImGuiSortDirection_ = 2;
pub type ImGuiSortDirection_ = c_uint;
pub const ImGuiKey_None: ImGuiKey = 0;
pub const ImGuiKey_Tab: ImGuiKey = 512;
pub const ImGuiKey_LeftArrow: ImGuiKey = 513;
pub const ImGuiKey_RightArrow: ImGuiKey = 514;
pub const ImGuiKey_UpArrow: ImGuiKey = 515;
pub const ImGuiKey_DownArrow: ImGuiKey = 516;
pub const ImGuiKey_PageUp: ImGuiKey = 517;
pub const ImGuiKey_PageDown: ImGuiKey = 518;
pub const ImGuiKey_Home: ImGuiKey = 519;
pub const ImGuiKey_End: ImGuiKey = 520;
pub const ImGuiKey_Insert: ImGuiKey = 521;
pub const ImGuiKey_Delete: ImGuiKey = 522;
pub const ImGuiKey_Backspace: ImGuiKey = 523;
pub const ImGuiKey_Space: ImGuiKey = 524;
pub const ImGuiKey_Enter: ImGuiKey = 525;
pub const ImGuiKey_Escape: ImGuiKey = 526;
pub const ImGuiKey_LeftCtrl: ImGuiKey = 527;
pub const ImGuiKey_LeftShift: ImGuiKey = 528;
pub const ImGuiKey_LeftAlt: ImGuiKey = 529;
pub const ImGuiKey_LeftSuper: ImGuiKey = 530;
pub const ImGuiKey_RightCtrl: ImGuiKey = 531;
pub const ImGuiKey_RightShift: ImGuiKey = 532;
pub const ImGuiKey_RightAlt: ImGuiKey = 533;
pub const ImGuiKey_RightSuper: ImGuiKey = 534;
pub const ImGuiKey_Menu: ImGuiKey = 535;
pub const ImGuiKey_0: ImGuiKey = 536;
pub const ImGuiKey_1: ImGuiKey = 537;
pub const ImGuiKey_2: ImGuiKey = 538;
pub const ImGuiKey_3: ImGuiKey = 539;
pub const ImGuiKey_4: ImGuiKey = 540;
pub const ImGuiKey_5: ImGuiKey = 541;
pub const ImGuiKey_6: ImGuiKey = 542;
pub const ImGuiKey_7: ImGuiKey = 543;
pub const ImGuiKey_8: ImGuiKey = 544;
pub const ImGuiKey_9: ImGuiKey = 545;
pub const ImGuiKey_A: ImGuiKey = 546;
pub const ImGuiKey_B: ImGuiKey = 547;
pub const ImGuiKey_C: ImGuiKey = 548;
pub const ImGuiKey_D: ImGuiKey = 549;
pub const ImGuiKey_E: ImGuiKey = 550;
pub const ImGuiKey_F: ImGuiKey = 551;
pub const ImGuiKey_G: ImGuiKey = 552;
pub const ImGuiKey_H: ImGuiKey = 553;
pub const ImGuiKey_I: ImGuiKey = 554;
pub const ImGuiKey_J: ImGuiKey = 555;
pub const ImGuiKey_K: ImGuiKey = 556;
pub const ImGuiKey_L: ImGuiKey = 557;
pub const ImGuiKey_M: ImGuiKey = 558;
pub const ImGuiKey_N: ImGuiKey = 559;
pub const ImGuiKey_O: ImGuiKey = 560;
pub const ImGuiKey_P: ImGuiKey = 561;
pub const ImGuiKey_Q: ImGuiKey = 562;
pub const ImGuiKey_R: ImGuiKey = 563;
pub const ImGuiKey_S: ImGuiKey = 564;
pub const ImGuiKey_T: ImGuiKey = 565;
pub const ImGuiKey_U: ImGuiKey = 566;
pub const ImGuiKey_V: ImGuiKey = 567;
pub const ImGuiKey_W: ImGuiKey = 568;
pub const ImGuiKey_X: ImGuiKey = 569;
pub const ImGuiKey_Y: ImGuiKey = 570;
pub const ImGuiKey_Z: ImGuiKey = 571;
pub const ImGuiKey_F1: ImGuiKey = 572;
pub const ImGuiKey_F2: ImGuiKey = 573;
pub const ImGuiKey_F3: ImGuiKey = 574;
pub const ImGuiKey_F4: ImGuiKey = 575;
pub const ImGuiKey_F5: ImGuiKey = 576;
pub const ImGuiKey_F6: ImGuiKey = 577;
pub const ImGuiKey_F7: ImGuiKey = 578;
pub const ImGuiKey_F8: ImGuiKey = 579;
pub const ImGuiKey_F9: ImGuiKey = 580;
pub const ImGuiKey_F10: ImGuiKey = 581;
pub const ImGuiKey_F11: ImGuiKey = 582;
pub const ImGuiKey_F12: ImGuiKey = 583;
pub const ImGuiKey_Apostrophe: ImGuiKey = 584;
pub const ImGuiKey_Comma: ImGuiKey = 585;
pub const ImGuiKey_Minus: ImGuiKey = 586;
pub const ImGuiKey_Period: ImGuiKey = 587;
pub const ImGuiKey_Slash: ImGuiKey = 588;
pub const ImGuiKey_Semicolon: ImGuiKey = 589;
pub const ImGuiKey_Equal: ImGuiKey = 590;
pub const ImGuiKey_LeftBracket: ImGuiKey = 591;
pub const ImGuiKey_Backslash: ImGuiKey = 592;
pub const ImGuiKey_RightBracket: ImGuiKey = 593;
pub const ImGuiKey_GraveAccent: ImGuiKey = 594;
pub const ImGuiKey_CapsLock: ImGuiKey = 595;
pub const ImGuiKey_ScrollLock: ImGuiKey = 596;
pub const ImGuiKey_NumLock: ImGuiKey = 597;
pub const ImGuiKey_PrintScreen: ImGuiKey = 598;
pub const ImGuiKey_Pause: ImGuiKey = 599;
pub const ImGuiKey_Keypad0: ImGuiKey = 600;
pub const ImGuiKey_Keypad1: ImGuiKey = 601;
pub const ImGuiKey_Keypad2: ImGuiKey = 602;
pub const ImGuiKey_Keypad3: ImGuiKey = 603;
pub const ImGuiKey_Keypad4: ImGuiKey = 604;
pub const ImGuiKey_Keypad5: ImGuiKey = 605;
pub const ImGuiKey_Keypad6: ImGuiKey = 606;
pub const ImGuiKey_Keypad7: ImGuiKey = 607;
pub const ImGuiKey_Keypad8: ImGuiKey = 608;
pub const ImGuiKey_Keypad9: ImGuiKey = 609;
pub const ImGuiKey_KeypadDecimal: ImGuiKey = 610;
pub const ImGuiKey_KeypadDivide: ImGuiKey = 611;
pub const ImGuiKey_KeypadMultiply: ImGuiKey = 612;
pub const ImGuiKey_KeypadSubtract: ImGuiKey = 613;
pub const ImGuiKey_KeypadAdd: ImGuiKey = 614;
pub const ImGuiKey_KeypadEnter: ImGuiKey = 615;
pub const ImGuiKey_KeypadEqual: ImGuiKey = 616;
pub const ImGuiKey_GamepadStart: ImGuiKey = 617;
pub const ImGuiKey_GamepadBack: ImGuiKey = 618;
pub const ImGuiKey_GamepadFaceLeft: ImGuiKey = 619;
pub const ImGuiKey_GamepadFaceRight: ImGuiKey = 620;
pub const ImGuiKey_GamepadFaceUp: ImGuiKey = 621;
pub const ImGuiKey_GamepadFaceDown: ImGuiKey = 622;
pub const ImGuiKey_GamepadDpadLeft: ImGuiKey = 623;
pub const ImGuiKey_GamepadDpadRight: ImGuiKey = 624;
pub const ImGuiKey_GamepadDpadUp: ImGuiKey = 625;
pub const ImGuiKey_GamepadDpadDown: ImGuiKey = 626;
pub const ImGuiKey_GamepadL1: ImGuiKey = 627;
pub const ImGuiKey_GamepadR1: ImGuiKey = 628;
pub const ImGuiKey_GamepadL2: ImGuiKey = 629;
pub const ImGuiKey_GamepadR2: ImGuiKey = 630;
pub const ImGuiKey_GamepadL3: ImGuiKey = 631;
pub const ImGuiKey_GamepadR3: ImGuiKey = 632;
pub const ImGuiKey_GamepadLStickLeft: ImGuiKey = 633;
pub const ImGuiKey_GamepadLStickRight: ImGuiKey = 634;
pub const ImGuiKey_GamepadLStickUp: ImGuiKey = 635;
pub const ImGuiKey_GamepadLStickDown: ImGuiKey = 636;
pub const ImGuiKey_GamepadRStickLeft: ImGuiKey = 637;
pub const ImGuiKey_GamepadRStickRight: ImGuiKey = 638;
pub const ImGuiKey_GamepadRStickUp: ImGuiKey = 639;
pub const ImGuiKey_GamepadRStickDown: ImGuiKey = 640;
pub const ImGuiKey_MouseLeft: ImGuiKey = 641;
pub const ImGuiKey_MouseRight: ImGuiKey = 642;
pub const ImGuiKey_MouseMiddle: ImGuiKey = 643;
pub const ImGuiKey_MouseX1: ImGuiKey = 644;
pub const ImGuiKey_MouseX2: ImGuiKey = 645;
pub const ImGuiKey_MouseWheelX: ImGuiKey = 646;
pub const ImGuiKey_MouseWheelY: ImGuiKey = 647;
pub const ImGuiKey_ReservedForModCtrl: ImGuiKey = 648;
pub const ImGuiKey_ReservedForModShift: ImGuiKey = 649;
pub const ImGuiKey_ReservedForModAlt: ImGuiKey = 650;
pub const ImGuiKey_ReservedForModSuper: ImGuiKey = 651;
pub const ImGuiKey_COUNT: ImGuiKey = 652;
pub const ImGuiMod_None: ImGuiKey = 0;
pub const ImGuiMod_Ctrl: ImGuiKey = 4096;
pub const ImGuiMod_Shift: ImGuiKey = 8192;
pub const ImGuiMod_Alt: ImGuiKey = 16384;
pub const ImGuiMod_Super: ImGuiKey = 32768;
pub const ImGuiMod_Shortcut: ImGuiKey = 2048;
pub const ImGuiMod_Mask_: ImGuiKey = 63488;
pub const ImGuiKey_NamedKey_BEGIN: ImGuiKey = 512;
pub const ImGuiKey_NamedKey_END: ImGuiKey = 652;
pub const ImGuiKey_NamedKey_COUNT: ImGuiKey = 140;
pub const ImGuiKey_KeysData_SIZE: ImGuiKey = 652;
pub const ImGuiKey_KeysData_OFFSET: ImGuiKey = 0;
pub type ImGuiKey = c_uint;
pub const ImGuiNavInput_Activate: ImGuiNavInput = 0;
pub const ImGuiNavInput_Cancel: ImGuiNavInput = 1;
pub const ImGuiNavInput_Input: ImGuiNavInput = 2;
pub const ImGuiNavInput_Menu: ImGuiNavInput = 3;
pub const ImGuiNavInput_DpadLeft: ImGuiNavInput = 4;
pub const ImGuiNavInput_DpadRight: ImGuiNavInput = 5;
pub const ImGuiNavInput_DpadUp: ImGuiNavInput = 6;
pub const ImGuiNavInput_DpadDown: ImGuiNavInput = 7;
pub const ImGuiNavInput_LStickLeft: ImGuiNavInput = 8;
pub const ImGuiNavInput_LStickRight: ImGuiNavInput = 9;
pub const ImGuiNavInput_LStickUp: ImGuiNavInput = 10;
pub const ImGuiNavInput_LStickDown: ImGuiNavInput = 11;
pub const ImGuiNavInput_FocusPrev: ImGuiNavInput = 12;
pub const ImGuiNavInput_FocusNext: ImGuiNavInput = 13;
pub const ImGuiNavInput_TweakSlow: ImGuiNavInput = 14;
pub const ImGuiNavInput_TweakFast: ImGuiNavInput = 15;
pub const ImGuiNavInput_COUNT: ImGuiNavInput = 16;
pub type ImGuiNavInput = c_uint;
pub const ImGuiConfigFlags_None: ImGuiConfigFlags_ = 0;
pub const ImGuiConfigFlags_NavEnableKeyboard: ImGuiConfigFlags_ = 1;
pub const ImGuiConfigFlags_NavEnableGamepad: ImGuiConfigFlags_ = 2;
pub const ImGuiConfigFlags_NavEnableSetMousePos: ImGuiConfigFlags_ = 4;
pub const ImGuiConfigFlags_NavNoCaptureKeyboard: ImGuiConfigFlags_ = 8;
pub const ImGuiConfigFlags_NoMouse: ImGuiConfigFlags_ = 16;
pub const ImGuiConfigFlags_NoMouseCursorChange: ImGuiConfigFlags_ = 32;
pub const ImGuiConfigFlags_DockingEnable: ImGuiConfigFlags_ = 64;
pub const ImGuiConfigFlags_ViewportsEnable: ImGuiConfigFlags_ = 1024;
pub const ImGuiConfigFlags_DpiEnableScaleViewports: ImGuiConfigFlags_ = 16384;
pub const ImGuiConfigFlags_DpiEnableScaleFonts: ImGuiConfigFlags_ = 32768;
pub const ImGuiConfigFlags_IsSRGB: ImGuiConfigFlags_ = 1048576;
pub const ImGuiConfigFlags_IsTouchScreen: ImGuiConfigFlags_ = 2097152;
pub type ImGuiConfigFlags_ = c_uint;
pub const ImGuiBackendFlags_None: ImGuiBackendFlags_ = 0;
pub const ImGuiBackendFlags_HasGamepad: ImGuiBackendFlags_ = 1;
pub const ImGuiBackendFlags_HasMouseCursors: ImGuiBackendFlags_ = 2;
pub const ImGuiBackendFlags_HasSetMousePos: ImGuiBackendFlags_ = 4;
pub const ImGuiBackendFlags_RendererHasVtxOffset: ImGuiBackendFlags_ = 8;
pub const ImGuiBackendFlags_PlatformHasViewports: ImGuiBackendFlags_ = 1024;
pub const ImGuiBackendFlags_HasMouseHoveredViewport: ImGuiBackendFlags_ = 2048;
pub const ImGuiBackendFlags_RendererHasViewports: ImGuiBackendFlags_ = 4096;
pub type ImGuiBackendFlags_ = c_uint;
pub const ImGuiCol_Text: ImGuiCol_ = 0;
pub const ImGuiCol_TextDisabled: ImGuiCol_ = 1;
pub const ImGuiCol_WindowBg: ImGuiCol_ = 2;
pub const ImGuiCol_ChildBg: ImGuiCol_ = 3;
pub const ImGuiCol_PopupBg: ImGuiCol_ = 4;
pub const ImGuiCol_Border: ImGuiCol_ = 5;
pub const ImGuiCol_BorderShadow: ImGuiCol_ = 6;
pub const ImGuiCol_FrameBg: ImGuiCol_ = 7;
pub const ImGuiCol_FrameBgHovered: ImGuiCol_ = 8;
pub const ImGuiCol_FrameBgActive: ImGuiCol_ = 9;
pub const ImGuiCol_TitleBg: ImGuiCol_ = 10;
pub const ImGuiCol_TitleBgActive: ImGuiCol_ = 11;
pub const ImGuiCol_TitleBgCollapsed: ImGuiCol_ = 12;
pub const ImGuiCol_MenuBarBg: ImGuiCol_ = 13;
pub const ImGuiCol_ScrollbarBg: ImGuiCol_ = 14;
pub const ImGuiCol_ScrollbarGrab: ImGuiCol_ = 15;
pub const ImGuiCol_ScrollbarGrabHovered: ImGuiCol_ = 16;
pub const ImGuiCol_ScrollbarGrabActive: ImGuiCol_ = 17;
pub const ImGuiCol_CheckMark: ImGuiCol_ = 18;
pub const ImGuiCol_SliderGrab: ImGuiCol_ = 19;
pub const ImGuiCol_SliderGrabActive: ImGuiCol_ = 20;
pub const ImGuiCol_Button: ImGuiCol_ = 21;
pub const ImGuiCol_ButtonHovered: ImGuiCol_ = 22;
pub const ImGuiCol_ButtonActive: ImGuiCol_ = 23;
pub const ImGuiCol_Header: ImGuiCol_ = 24;
pub const ImGuiCol_HeaderHovered: ImGuiCol_ = 25;
pub const ImGuiCol_HeaderActive: ImGuiCol_ = 26;
pub const ImGuiCol_Separator: ImGuiCol_ = 27;
pub const ImGuiCol_SeparatorHovered: ImGuiCol_ = 28;
pub const ImGuiCol_SeparatorActive: ImGuiCol_ = 29;
pub const ImGuiCol_ResizeGrip: ImGuiCol_ = 30;
pub const ImGuiCol_ResizeGripHovered: ImGuiCol_ = 31;
pub const ImGuiCol_ResizeGripActive: ImGuiCol_ = 32;
pub const ImGuiCol_Tab: ImGuiCol_ = 33;
pub const ImGuiCol_TabHovered: ImGuiCol_ = 34;
pub const ImGuiCol_TabActive: ImGuiCol_ = 35;
pub const ImGuiCol_TabUnfocused: ImGuiCol_ = 36;
pub const ImGuiCol_TabUnfocusedActive: ImGuiCol_ = 37;
pub const ImGuiCol_DockingPreview: ImGuiCol_ = 38;
pub const ImGuiCol_DockingEmptyBg: ImGuiCol_ = 39;
pub const ImGuiCol_PlotLines: ImGuiCol_ = 40;
pub const ImGuiCol_PlotLinesHovered: ImGuiCol_ = 41;
pub const ImGuiCol_PlotHistogram: ImGuiCol_ = 42;
pub const ImGuiCol_PlotHistogramHovered: ImGuiCol_ = 43;
pub const ImGuiCol_TableHeaderBg: ImGuiCol_ = 44;
pub const ImGuiCol_TableBorderStrong: ImGuiCol_ = 45;
pub const ImGuiCol_TableBorderLight: ImGuiCol_ = 46;
pub const ImGuiCol_TableRowBg: ImGuiCol_ = 47;
pub const ImGuiCol_TableRowBgAlt: ImGuiCol_ = 48;
pub const ImGuiCol_TextSelectedBg: ImGuiCol_ = 49;
pub const ImGuiCol_DragDropTarget: ImGuiCol_ = 50;
pub const ImGuiCol_NavHighlight: ImGuiCol_ = 51;
pub const ImGuiCol_NavWindowingHighlight: ImGuiCol_ = 52;
pub const ImGuiCol_NavWindowingDimBg: ImGuiCol_ = 53;
pub const ImGuiCol_ModalWindowDimBg: ImGuiCol_ = 54;
pub const ImGuiCol_COUNT: ImGuiCol_ = 55;
pub type ImGuiCol_ = c_uint;
pub const ImGuiStyleVar_Alpha: ImGuiStyleVar_ = 0;
pub const ImGuiStyleVar_DisabledAlpha: ImGuiStyleVar_ = 1;
pub const ImGuiStyleVar_WindowPadding: ImGuiStyleVar_ = 2;
pub const ImGuiStyleVar_WindowRounding: ImGuiStyleVar_ = 3;
pub const ImGuiStyleVar_WindowBorderSize: ImGuiStyleVar_ = 4;
pub const ImGuiStyleVar_WindowMinSize: ImGuiStyleVar_ = 5;
pub const ImGuiStyleVar_WindowTitleAlign: ImGuiStyleVar_ = 6;
pub const ImGuiStyleVar_ChildRounding: ImGuiStyleVar_ = 7;
pub const ImGuiStyleVar_ChildBorderSize: ImGuiStyleVar_ = 8;
pub const ImGuiStyleVar_PopupRounding: ImGuiStyleVar_ = 9;
pub const ImGuiStyleVar_PopupBorderSize: ImGuiStyleVar_ = 10;
pub const ImGuiStyleVar_FramePadding: ImGuiStyleVar_ = 11;
pub const ImGuiStyleVar_FrameRounding: ImGuiStyleVar_ = 12;
pub const ImGuiStyleVar_FrameBorderSize: ImGuiStyleVar_ = 13;
pub const ImGuiStyleVar_ItemSpacing: ImGuiStyleVar_ = 14;
pub const ImGuiStyleVar_ItemInnerSpacing: ImGuiStyleVar_ = 15;
pub const ImGuiStyleVar_IndentSpacing: ImGuiStyleVar_ = 16;
pub const ImGuiStyleVar_CellPadding: ImGuiStyleVar_ = 17;
pub const ImGuiStyleVar_ScrollbarSize: ImGuiStyleVar_ = 18;
pub const ImGuiStyleVar_ScrollbarRounding: ImGuiStyleVar_ = 19;
pub const ImGuiStyleVar_GrabMinSize: ImGuiStyleVar_ = 20;
pub const ImGuiStyleVar_GrabRounding: ImGuiStyleVar_ = 21;
pub const ImGuiStyleVar_TabRounding: ImGuiStyleVar_ = 22;
pub const ImGuiStyleVar_ButtonTextAlign: ImGuiStyleVar_ = 23;
pub const ImGuiStyleVar_SelectableTextAlign: ImGuiStyleVar_ = 24;
pub const ImGuiStyleVar_COUNT: ImGuiStyleVar_ = 25;
pub type ImGuiStyleVar_ = c_uint;
pub const ImGuiButtonFlags_None: ImGuiButtonFlags_ = 0;
pub const ImGuiButtonFlags_MouseButtonLeft: ImGuiButtonFlags_ = 1;
pub const ImGuiButtonFlags_MouseButtonRight: ImGuiButtonFlags_ = 2;
pub const ImGuiButtonFlags_MouseButtonMiddle: ImGuiButtonFlags_ = 4;
pub const ImGuiButtonFlags_MouseButtonMask_: ImGuiButtonFlags_ = 7;
pub const ImGuiButtonFlags_MouseButtonDefault_: ImGuiButtonFlags_ = 1;
pub type ImGuiButtonFlags_ = c_uint;
pub const ImGuiColorEditFlags_None: ImGuiColorEditFlags_ = 0;
pub const ImGuiColorEditFlags_NoAlpha: ImGuiColorEditFlags_ = 2;
pub const ImGuiColorEditFlags_NoPicker: ImGuiColorEditFlags_ = 4;
pub const ImGuiColorEditFlags_NoOptions: ImGuiColorEditFlags_ = 8;
pub const ImGuiColorEditFlags_NoSmallPreview: ImGuiColorEditFlags_ = 16;
pub const ImGuiColorEditFlags_NoInputs: ImGuiColorEditFlags_ = 32;
pub const ImGuiColorEditFlags_NoTooltip: ImGuiColorEditFlags_ = 64;
pub const ImGuiColorEditFlags_NoLabel: ImGuiColorEditFlags_ = 128;
pub const ImGuiColorEditFlags_NoSidePreview: ImGuiColorEditFlags_ = 256;
pub const ImGuiColorEditFlags_NoDragDrop: ImGuiColorEditFlags_ = 512;
pub const ImGuiColorEditFlags_NoBorder: ImGuiColorEditFlags_ = 1024;
pub const ImGuiColorEditFlags_AlphaBar: ImGuiColorEditFlags_ = 65536;
pub const ImGuiColorEditFlags_AlphaPreview: ImGuiColorEditFlags_ = 131072;
pub const ImGuiColorEditFlags_AlphaPreviewHalf: ImGuiColorEditFlags_ = 262144;
pub const ImGuiColorEditFlags_HDR: ImGuiColorEditFlags_ = 524288;
pub const ImGuiColorEditFlags_DisplayRGB: ImGuiColorEditFlags_ = 1048576;
pub const ImGuiColorEditFlags_DisplayHSV: ImGuiColorEditFlags_ = 2097152;
pub const ImGuiColorEditFlags_DisplayHex: ImGuiColorEditFlags_ = 4194304;
pub const ImGuiColorEditFlags_Uint8: ImGuiColorEditFlags_ = 8388608;
pub const ImGuiColorEditFlags_Float: ImGuiColorEditFlags_ = 16777216;
pub const ImGuiColorEditFlags_PickerHueBar: ImGuiColorEditFlags_ = 33554432;
pub const ImGuiColorEditFlags_PickerHueWheel: ImGuiColorEditFlags_ = 67108864;
pub const ImGuiColorEditFlags_InputRGB: ImGuiColorEditFlags_ = 134217728;
pub const ImGuiColorEditFlags_InputHSV: ImGuiColorEditFlags_ = 268435456;
pub const ImGuiColorEditFlags_DefaultOptions_: ImGuiColorEditFlags_ = 177209344;
pub const ImGuiColorEditFlags_DisplayMask_: ImGuiColorEditFlags_ = 7340032;
pub const ImGuiColorEditFlags_DataTypeMask_: ImGuiColorEditFlags_ = 25165824;
pub const ImGuiColorEditFlags_PickerMask_: ImGuiColorEditFlags_ = 100663296;
pub const ImGuiColorEditFlags_InputMask_: ImGuiColorEditFlags_ = 402653184;
pub type ImGuiColorEditFlags_ = c_uint;
pub const ImGuiSliderFlags_None: ImGuiSliderFlags_ = 0;
pub const ImGuiSliderFlags_AlwaysClamp: ImGuiSliderFlags_ = 16;
pub const ImGuiSliderFlags_Logarithmic: ImGuiSliderFlags_ = 32;
pub const ImGuiSliderFlags_NoRoundToFormat: ImGuiSliderFlags_ = 64;
pub const ImGuiSliderFlags_NoInput: ImGuiSliderFlags_ = 128;
pub const ImGuiSliderFlags_InvalidMask_: ImGuiSliderFlags_ = 1879048207;
pub type ImGuiSliderFlags_ = c_uint;
pub const ImGuiMouseButton_Left: ImGuiMouseButton_ = 0;
pub const ImGuiMouseButton_Right: ImGuiMouseButton_ = 1;
pub const ImGuiMouseButton_Middle: ImGuiMouseButton_ = 2;
pub const ImGuiMouseButton_COUNT: ImGuiMouseButton_ = 5;
pub type ImGuiMouseButton_ = c_uint;
pub const ImGuiMouseCursor_None: ImGuiMouseCursor_ = -1;
pub const ImGuiMouseCursor_Arrow: ImGuiMouseCursor_ = 0;
pub const ImGuiMouseCursor_TextInput: ImGuiMouseCursor_ = 1;
pub const ImGuiMouseCursor_ResizeAll: ImGuiMouseCursor_ = 2;
pub const ImGuiMouseCursor_ResizeNS: ImGuiMouseCursor_ = 3;
pub const ImGuiMouseCursor_ResizeEW: ImGuiMouseCursor_ = 4;
pub const ImGuiMouseCursor_ResizeNESW: ImGuiMouseCursor_ = 5;
pub const ImGuiMouseCursor_ResizeNWSE: ImGuiMouseCursor_ = 6;
pub const ImGuiMouseCursor_Hand: ImGuiMouseCursor_ = 7;
pub const ImGuiMouseCursor_NotAllowed: ImGuiMouseCursor_ = 8;
pub const ImGuiMouseCursor_COUNT: ImGuiMouseCursor_ = 9;
pub type ImGuiMouseCursor_ = c_int;
pub const ImGuiCond_None: ImGuiCond_ = 0;
pub const ImGuiCond_Always: ImGuiCond_ = 1;
pub const ImGuiCond_Once: ImGuiCond_ = 2;
pub const ImGuiCond_FirstUseEver: ImGuiCond_ = 4;
pub const ImGuiCond_Appearing: ImGuiCond_ = 8;
pub type ImGuiCond_ = c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiStyle {
    pub Alpha: f32,
    pub DisabledAlpha: f32,
    pub WindowPadding: ImVec2,
    pub WindowRounding: f32,
    pub WindowBorderSize: f32,
    pub WindowMinSize: ImVec2,
    pub WindowTitleAlign: ImVec2,
    pub WindowMenuButtonPosition: ImGuiDir,
    pub ChildRounding: f32,
    pub ChildBorderSize: f32,
    pub PopupRounding: f32,
    pub PopupBorderSize: f32,
    pub FramePadding: ImVec2,
    pub FrameRounding: f32,
    pub FrameBorderSize: f32,
    pub ItemSpacing: ImVec2,
    pub ItemInnerSpacing: ImVec2,
    pub CellPadding: ImVec2,
    pub TouchExtraPadding: ImVec2,
    pub IndentSpacing: f32,
    pub ColumnsMinSpacing: f32,
    pub ScrollbarSize: f32,
    pub ScrollbarRounding: f32,
    pub GrabMinSize: f32,
    pub GrabRounding: f32,
    pub LogSliderDeadzone: f32,
    pub TabRounding: f32,
    pub TabBorderSize: f32,
    pub TabMinWidthForCloseButton: f32,
    pub ColorButtonPosition: ImGuiDir,
    pub ButtonTextAlign: ImVec2,
    pub SelectableTextAlign: ImVec2,
    pub DisplayWindowPadding: ImVec2,
    pub DisplaySafeAreaPadding: ImVec2,
    pub MouseCursorScale: f32,
    pub AntiAliasedLines: bool,
    pub AntiAliasedLinesUseTex: bool,
    pub AntiAliasedFill: bool,
    pub CurveTessellationTol: f32,
    pub CircleTessellationMaxError: f32,
    pub Colors: [ImVec4; 55usize],
}
impl Default for ImGuiStyle {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiKeyData {
    pub Down: bool,
    pub DownDuration: f32,
    pub DownDurationPrev: f32,
    pub AnalogValue: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImWchar {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImWchar,
}
impl Default for ImVector_ImWchar {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiIO {
    pub ConfigFlags: ImGuiConfigFlags,
    pub BackendFlags: ImGuiBackendFlags,
    pub DisplaySize: ImVec2,
    pub DeltaTime: f32,
    pub IniSavingRate: f32,
    pub IniFilename: *const c_char,
    pub LogFilename: *const c_char,
    pub MouseDoubleClickTime: f32,
    pub MouseDoubleClickMaxDist: f32,
    pub MouseDragThreshold: f32,
    pub KeyRepeatDelay: f32,
    pub KeyRepeatRate: f32,
    pub HoverDelayNormal: f32,
    pub HoverDelayShort: f32,
    pub UserData: *mut c_void,
    pub Fonts: *mut ImFontAtlas,
    pub FontGlobalScale: f32,
    pub FontAllowUserScaling: bool,
    pub FontDefault: *mut ImFont,
    pub DisplayFramebufferScale: ImVec2,
    pub ConfigDockingNoSplit: bool,
    pub ConfigDockingWithShift: bool,
    pub ConfigDockingAlwaysTabBar: bool,
    pub ConfigDockingTransparentPayload: bool,
    pub ConfigViewportsNoAutoMerge: bool,
    pub ConfigViewportsNoTaskBarIcon: bool,
    pub ConfigViewportsNoDecoration: bool,
    pub ConfigViewportsNoDefaultParent: bool,
    pub MouseDrawCursor: bool,
    pub ConfigMacOSXBehaviors: bool,
    pub ConfigInputTrickleEventQueue: bool,
    pub ConfigInputTextCursorBlink: bool,
    pub ConfigInputTextEnterKeepActive: bool,
    pub ConfigDragClickToInputText: bool,
    pub ConfigWindowsResizeFromEdges: bool,
    pub ConfigWindowsMoveFromTitleBarOnly: bool,
    pub ConfigMemoryCompactTimer: f32,
    pub BackendPlatformName: *const c_char,
    pub BackendRendererName: *const c_char,
    pub BackendPlatformUserData: *mut c_void,
    pub BackendRendererUserData: *mut c_void,
    pub BackendLanguageUserData: *mut c_void,
    pub GetClipboardTextFn: ::core::option::Option<unsafe extern "C" fn(user_data: *mut c_void) -> *const c_char>,
    pub SetClipboardTextFn: ::core::option::Option<unsafe extern "C" fn(user_data: *mut c_void, text: *const c_char)>,
    pub ClipboardUserData: *mut c_void,
    pub SetPlatformImeDataFn:
        ::core::option::Option<unsafe extern "C" fn(viewport: *mut ImGuiViewport, data: *mut ImGuiPlatformImeData)>,
    pub _UnusedPadding: *mut c_void,
    pub WantCaptureMouse: bool,
    pub WantCaptureKeyboard: bool,
    pub WantTextInput: bool,
    pub WantSetMousePos: bool,
    pub WantSaveIniSettings: bool,
    pub NavActive: bool,
    pub NavVisible: bool,
    pub Framerate: f32,
    pub MetricsRenderVertices: c_int,
    pub MetricsRenderIndices: c_int,
    pub MetricsRenderWindows: c_int,
    pub MetricsActiveWindows: c_int,
    pub MetricsActiveAllocations: c_int,
    pub MouseDelta: ImVec2,
    pub KeyMap: [c_int; 652usize],
    pub KeysDown: [bool; 652usize],
    pub NavInputs: [f32; 16usize],
    pub MousePos: ImVec2,
    pub MouseDown: [bool; 5usize],
    pub MouseWheel: f32,
    pub MouseWheelH: f32,
    pub MouseHoveredViewport: ImGuiID,
    pub KeyCtrl: bool,
    pub KeyShift: bool,
    pub KeyAlt: bool,
    pub KeySuper: bool,
    pub KeyMods: ImGuiKeyChord,
    pub KeysData: [ImGuiKeyData; 652usize],
    pub WantCaptureMouseUnlessPopupClose: bool,
    pub MousePosPrev: ImVec2,
    pub MouseClickedPos: [ImVec2; 5usize],
    pub MouseClickedTime: [f64; 5usize],
    pub MouseClicked: [bool; 5usize],
    pub MouseDoubleClicked: [bool; 5usize],
    pub MouseClickedCount: [ImU16; 5usize],
    pub MouseClickedLastCount: [ImU16; 5usize],
    pub MouseReleased: [bool; 5usize],
    pub MouseDownOwned: [bool; 5usize],
    pub MouseDownOwnedUnlessPopupClose: [bool; 5usize],
    pub MouseDownDuration: [f32; 5usize],
    pub MouseDownDurationPrev: [f32; 5usize],
    pub MouseDragMaxDistanceAbs: [ImVec2; 5usize],
    pub MouseDragMaxDistanceSqr: [f32; 5usize],
    pub PenPressure: f32,
    pub AppFocusLost: bool,
    pub AppAcceptingEvents: bool,
    pub BackendUsingLegacyKeyArrays: ImS8,
    pub BackendUsingLegacyNavInputArray: bool,
    pub InputQueueSurrogate: ImWchar16,
    pub InputQueueCharacters: ImVector_ImWchar,
}
impl Default for ImGuiIO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiInputTextCallbackData {
    pub EventFlag: ImGuiInputTextFlags,
    pub Flags: ImGuiInputTextFlags,
    pub UserData: *mut c_void,
    pub EventChar: ImWchar,
    pub EventKey: ImGuiKey,
    pub Buf: *mut c_char,
    pub BufTextLen: c_int,
    pub BufSize: c_int,
    pub BufDirty: bool,
    pub CursorPos: c_int,
    pub SelectionStart: c_int,
    pub SelectionEnd: c_int,
}
impl Default for ImGuiInputTextCallbackData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiSizeCallbackData {
    pub UserData: *mut c_void,
    pub Pos: ImVec2,
    pub CurrentSize: ImVec2,
    pub DesiredSize: ImVec2,
}
impl Default for ImGuiSizeCallbackData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiWindowClass {
    pub ClassId: ImGuiID,
    pub ParentViewportId: ImGuiID,
    pub ViewportFlagsOverrideSet: ImGuiViewportFlags,
    pub ViewportFlagsOverrideClear: ImGuiViewportFlags,
    pub TabItemFlagsOverrideSet: ImGuiTabItemFlags,
    pub DockNodeFlagsOverrideSet: ImGuiDockNodeFlags,
    pub DockingAlwaysTabBar: bool,
    pub DockingAllowUnclassed: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiPayload {
    pub Data: *mut c_void,
    pub DataSize: c_int,
    pub SourceId: ImGuiID,
    pub SourceParentId: ImGuiID,
    pub DataFrameCount: c_int,
    pub DataType: [c_char; 33usize],
    pub Preview: bool,
    pub Delivery: bool,
}
impl Default for ImGuiPayload {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiTableColumnSortSpecs {
    pub ColumnUserID: ImGuiID,
    pub ColumnIndex: ImS16,
    pub SortOrder: ImS16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl ImGuiTableColumnSortSpecs {
    #[inline]
    pub fn SortDirection(&self) -> ImGuiSortDirection {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SortDirection(&mut self, val: ImGuiSortDirection) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SortDirection: ImGuiSortDirection) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let SortDirection: u32 = unsafe { ::core::mem::transmute(SortDirection) };
            SortDirection as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiTableSortSpecs {
    pub Specs: *const ImGuiTableColumnSortSpecs,
    pub SpecsCount: c_int,
    pub SpecsDirty: bool,
}
impl Default for ImGuiTableSortSpecs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiOnceUponAFrame {
    pub RefFrame: c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiTextRange {
    pub b: *const c_char,
    pub e: *const c_char,
}
impl Default for ImGuiTextRange {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiTextRange {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiTextRange,
}
impl Default for ImVector_ImGuiTextRange {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiTextFilter {
    pub InputBuf: [c_char; 256usize],
    pub Filters: ImVector_ImGuiTextRange,
    pub CountGrep: c_int,
}
impl Default for ImGuiTextFilter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_char {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut c_char,
}
impl Default for ImVector_char {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiTextBuffer {
    pub Buf: ImVector_char,
}
impl Default for ImGuiTextBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImGuiStoragePair {
    pub key: ImGuiID,
    pub __bindgen_anon_1: ImGuiStoragePair__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ImGuiStoragePair__bindgen_ty_1 {
    pub val_i: c_int,
    pub val_f: f32,
    pub val_p: *mut c_void,
}
impl Default for ImGuiStoragePair__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for ImGuiStoragePair__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "ImGuiStoragePair__bindgen_ty_1 {{ union }}")
    }
}
impl Default for ImGuiStoragePair {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for ImGuiStoragePair {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "ImGuiStoragePair {{ key: {:?}, __bindgen_anon_1: {:?} }}", self.key, self.__bindgen_anon_1)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiStoragePair {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiStoragePair,
}
impl Default for ImVector_ImGuiStoragePair {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiStorage {
    pub Data: ImVector_ImGuiStoragePair,
}
impl Default for ImGuiStorage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiListClipper {
    pub DisplayStart: c_int,
    pub DisplayEnd: c_int,
    pub ItemsCount: c_int,
    pub ItemsHeight: f32,
    pub StartPosY: f32,
    pub TempData: *mut c_void,
}
impl Default for ImGuiListClipper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImColor {
    pub Value: ImVec4,
}
pub type ImDrawCallback =
    ::core::option::Option<unsafe extern "C" fn(parent_list: *const ImDrawList, cmd: *const ImDrawCmd)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImDrawCmd {
    pub ClipRect: ImVec4,
    pub TextureId: ImTextureID,
    pub VtxOffset: c_uint,
    pub IdxOffset: c_uint,
    pub ElemCount: c_uint,
    pub UserCallback: ImDrawCallback,
    pub UserCallbackData: *mut c_void,
}
impl Default for ImDrawCmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImDrawVert {
    pub pos: ImVec2,
    pub uv: ImVec2,
    pub col: ImU32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImDrawCmdHeader {
    pub ClipRect: ImVec4,
    pub TextureId: ImTextureID,
    pub VtxOffset: c_uint,
}
impl Default for ImDrawCmdHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImDrawCmd {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImDrawCmd,
}
impl Default for ImVector_ImDrawCmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImDrawIdx {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImDrawIdx,
}
impl Default for ImVector_ImDrawIdx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImDrawChannel {
    pub _CmdBuffer: ImVector_ImDrawCmd,
    pub _IdxBuffer: ImVector_ImDrawIdx,
}
impl Default for ImDrawChannel {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImDrawChannel {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImDrawChannel,
}
impl Default for ImVector_ImDrawChannel {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImDrawListSplitter {
    pub _Current: c_int,
    pub _Count: c_int,
    pub _Channels: ImVector_ImDrawChannel,
}
impl Default for ImDrawListSplitter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImDrawFlags_None: ImDrawFlags_ = 0;
pub const ImDrawFlags_Closed: ImDrawFlags_ = 1;
pub const ImDrawFlags_RoundCornersTopLeft: ImDrawFlags_ = 16;
pub const ImDrawFlags_RoundCornersTopRight: ImDrawFlags_ = 32;
pub const ImDrawFlags_RoundCornersBottomLeft: ImDrawFlags_ = 64;
pub const ImDrawFlags_RoundCornersBottomRight: ImDrawFlags_ = 128;
pub const ImDrawFlags_RoundCornersNone: ImDrawFlags_ = 256;
pub const ImDrawFlags_RoundCornersTop: ImDrawFlags_ = 48;
pub const ImDrawFlags_RoundCornersBottom: ImDrawFlags_ = 192;
pub const ImDrawFlags_RoundCornersLeft: ImDrawFlags_ = 80;
pub const ImDrawFlags_RoundCornersRight: ImDrawFlags_ = 160;
pub const ImDrawFlags_RoundCornersAll: ImDrawFlags_ = 240;
pub const ImDrawFlags_RoundCornersDefault_: ImDrawFlags_ = 240;
pub const ImDrawFlags_RoundCornersMask_: ImDrawFlags_ = 496;
pub type ImDrawFlags_ = c_uint;
pub const ImDrawListFlags_None: ImDrawListFlags_ = 0;
pub const ImDrawListFlags_AntiAliasedLines: ImDrawListFlags_ = 1;
pub const ImDrawListFlags_AntiAliasedLinesUseTex: ImDrawListFlags_ = 2;
pub const ImDrawListFlags_AntiAliasedFill: ImDrawListFlags_ = 4;
pub const ImDrawListFlags_AllowVtxOffset: ImDrawListFlags_ = 8;
pub type ImDrawListFlags_ = c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImDrawVert {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImDrawVert,
}
impl Default for ImVector_ImDrawVert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImVec4 {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImVec4,
}
impl Default for ImVector_ImVec4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImTextureID {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImTextureID,
}
impl Default for ImVector_ImTextureID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImVec2 {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImVec2,
}
impl Default for ImVector_ImVec2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImDrawList {
    pub CmdBuffer: ImVector_ImDrawCmd,
    pub IdxBuffer: ImVector_ImDrawIdx,
    pub VtxBuffer: ImVector_ImDrawVert,
    pub Flags: ImDrawListFlags,
    pub _VtxCurrentIdx: c_uint,
    pub _Data: *mut ImDrawListSharedData,
    pub _OwnerName: *const c_char,
    pub _VtxWritePtr: *mut ImDrawVert,
    pub _IdxWritePtr: *mut ImDrawIdx,
    pub _ClipRectStack: ImVector_ImVec4,
    pub _TextureIdStack: ImVector_ImTextureID,
    pub _Path: ImVector_ImVec2,
    pub _CmdHeader: ImDrawCmdHeader,
    pub _Splitter: ImDrawListSplitter,
    pub _FringeScale: f32,
}
impl Default for ImDrawList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImDrawData {
    pub Valid: bool,
    pub CmdListsCount: c_int,
    pub TotalIdxCount: c_int,
    pub TotalVtxCount: c_int,
    pub CmdLists: *mut *mut ImDrawList,
    pub DisplayPos: ImVec2,
    pub DisplaySize: ImVec2,
    pub FramebufferScale: ImVec2,
    pub OwnerViewport: *mut ImGuiViewport,
}
impl Default for ImDrawData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImFontConfig {
    pub FontData: *mut c_void,
    pub FontDataSize: c_int,
    pub FontDataOwnedByAtlas: bool,
    pub FontNo: c_int,
    pub SizePixels: f32,
    pub OversampleH: c_int,
    pub OversampleV: c_int,
    pub PixelSnapH: bool,
    pub GlyphExtraSpacing: ImVec2,
    pub GlyphOffset: ImVec2,
    pub GlyphRanges: *const ImWchar,
    pub GlyphMinAdvanceX: f32,
    pub GlyphMaxAdvanceX: f32,
    pub MergeMode: bool,
    pub FontBuilderFlags: c_uint,
    pub RasterizerMultiply: f32,
    pub EllipsisChar: ImWchar,
    pub Name: [c_char; 40usize],
    pub DstFont: *mut ImFont,
}
impl Default for ImFontConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImFontGlyph {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub AdvanceX: f32,
    pub X0: f32,
    pub Y0: f32,
    pub X1: f32,
    pub Y1: f32,
    pub U0: f32,
    pub V0: f32,
    pub U1: f32,
    pub V1: f32,
}
impl ImFontGlyph {
    #[inline]
    pub fn Colored(&self) -> c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Colored(&mut self, val: c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Visible(&self) -> c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Visible(&mut self, val: c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Codepoint(&self) -> c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Codepoint(&mut self, val: c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Colored: c_uint, Visible: c_uint, Codepoint: c_uint) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Colored: u32 = unsafe { ::core::mem::transmute(Colored) };
            Colored as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Visible: u32 = unsafe { ::core::mem::transmute(Visible) };
            Visible as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Codepoint: u32 = unsafe { ::core::mem::transmute(Codepoint) };
            Codepoint as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImU32 {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImU32,
}
impl Default for ImVector_ImU32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImFontGlyphRangesBuilder {
    pub UsedChars: ImVector_ImU32,
}
impl Default for ImFontGlyphRangesBuilder {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImFontAtlasCustomRect {
    pub Width: c_ushort,
    pub Height: c_ushort,
    pub X: c_ushort,
    pub Y: c_ushort,
    pub GlyphID: c_uint,
    pub GlyphAdvanceX: f32,
    pub GlyphOffset: ImVec2,
    pub Font: *mut ImFont,
}
impl Default for ImFontAtlasCustomRect {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImFontAtlasFlags_None: ImFontAtlasFlags_ = 0;
pub const ImFontAtlasFlags_NoPowerOfTwoHeight: ImFontAtlasFlags_ = 1;
pub const ImFontAtlasFlags_NoMouseCursors: ImFontAtlasFlags_ = 2;
pub const ImFontAtlasFlags_NoBakedLines: ImFontAtlasFlags_ = 4;
pub type ImFontAtlasFlags_ = c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImFontPtr {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut *mut ImFont,
}
impl Default for ImVector_ImFontPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImFontAtlasCustomRect {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImFontAtlasCustomRect,
}
impl Default for ImVector_ImFontAtlasCustomRect {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImFontConfig {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImFontConfig,
}
impl Default for ImVector_ImFontConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImFontAtlas {
    pub Flags: ImFontAtlasFlags,
    pub TexID: ImTextureID,
    pub TexDesiredWidth: c_int,
    pub TexGlyphPadding: c_int,
    pub Locked: bool,
    pub UserData: *mut c_void,
    pub TexReady: bool,
    pub TexPixelsUseColors: bool,
    pub TexPixelsAlpha8: *mut c_uchar,
    pub TexPixelsRGBA32: *mut c_uint,
    pub TexWidth: c_int,
    pub TexHeight: c_int,
    pub TexUvScale: ImVec2,
    pub TexUvWhitePixel: ImVec2,
    pub Fonts: ImVector_ImFontPtr,
    pub CustomRects: ImVector_ImFontAtlasCustomRect,
    pub ConfigData: ImVector_ImFontConfig,
    pub TexUvLines: [ImVec4; 64usize],
    pub FontBuilderIO: *const ImFontBuilderIO,
    pub FontBuilderFlags: c_uint,
    pub PackIdMouseCursors: c_int,
    pub PackIdLines: c_int,
}
impl Default for ImFontAtlas {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_float {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut f32,
}
impl Default for ImVector_float {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImFontGlyph {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImFontGlyph,
}
impl Default for ImVector_ImFontGlyph {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImFont {
    pub IndexAdvanceX: ImVector_float,
    pub FallbackAdvanceX: f32,
    pub FontSize: f32,
    pub IndexLookup: ImVector_ImWchar,
    pub Glyphs: ImVector_ImFontGlyph,
    pub FallbackGlyph: *const ImFontGlyph,
    pub ContainerAtlas: *mut ImFontAtlas,
    pub ConfigData: *const ImFontConfig,
    pub ConfigDataCount: c_short,
    pub FallbackChar: ImWchar,
    pub EllipsisChar: ImWchar,
    pub DotChar: ImWchar,
    pub DirtyLookupTables: bool,
    pub Scale: f32,
    pub Ascent: f32,
    pub Descent: f32,
    pub MetricsTotalSurface: c_int,
    pub Used4kPagesMap: [ImU8; 34usize],
}
impl Default for ImFont {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImGuiViewportFlags_None: ImGuiViewportFlags_ = 0;
pub const ImGuiViewportFlags_IsPlatformWindow: ImGuiViewportFlags_ = 1;
pub const ImGuiViewportFlags_IsPlatformMonitor: ImGuiViewportFlags_ = 2;
pub const ImGuiViewportFlags_OwnedByApp: ImGuiViewportFlags_ = 4;
pub const ImGuiViewportFlags_NoDecoration: ImGuiViewportFlags_ = 8;
pub const ImGuiViewportFlags_NoTaskBarIcon: ImGuiViewportFlags_ = 16;
pub const ImGuiViewportFlags_NoFocusOnAppearing: ImGuiViewportFlags_ = 32;
pub const ImGuiViewportFlags_NoFocusOnClick: ImGuiViewportFlags_ = 64;
pub const ImGuiViewportFlags_NoInputs: ImGuiViewportFlags_ = 128;
pub const ImGuiViewportFlags_NoRendererClear: ImGuiViewportFlags_ = 256;
pub const ImGuiViewportFlags_TopMost: ImGuiViewportFlags_ = 512;
pub const ImGuiViewportFlags_Minimized: ImGuiViewportFlags_ = 1024;
pub const ImGuiViewportFlags_NoAutoMerge: ImGuiViewportFlags_ = 2048;
pub const ImGuiViewportFlags_CanHostOtherWindows: ImGuiViewportFlags_ = 4096;
pub type ImGuiViewportFlags_ = c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiViewport {
    pub ID: ImGuiID,
    pub Flags: ImGuiViewportFlags,
    pub Pos: ImVec2,
    pub Size: ImVec2,
    pub WorkPos: ImVec2,
    pub WorkSize: ImVec2,
    pub DpiScale: f32,
    pub ParentViewportId: ImGuiID,
    pub DrawData: *mut ImDrawData,
    pub RendererUserData: *mut c_void,
    pub PlatformUserData: *mut c_void,
    pub PlatformHandle: *mut c_void,
    pub PlatformHandleRaw: *mut c_void,
    pub PlatformWindowCreated: bool,
    pub PlatformRequestMove: bool,
    pub PlatformRequestResize: bool,
    pub PlatformRequestClose: bool,
}
impl Default for ImGuiViewport {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiPlatformMonitor {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiPlatformMonitor,
}
impl Default for ImVector_ImGuiPlatformMonitor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiViewportPtr {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut *mut ImGuiViewport,
}
impl Default for ImVector_ImGuiViewportPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiPlatformIO {
    pub Platform_CreateWindow: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Platform_DestroyWindow: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Platform_ShowWindow: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Platform_SetWindowPos: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport, pos: ImVec2)>,
    pub Platform_GetWindowPos: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport) -> ImVec2>,
    pub Platform_SetWindowSize: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport, size: ImVec2)>,
    pub Platform_GetWindowSize: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport) -> ImVec2>,
    pub Platform_SetWindowFocus: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Platform_GetWindowFocus: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport) -> bool>,
    pub Platform_GetWindowMinimized: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport) -> bool>,
    pub Platform_SetWindowTitle:
        ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport, str_: *const c_char)>,
    pub Platform_SetWindowAlpha: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport, alpha: f32)>,
    pub Platform_UpdateWindow: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Platform_RenderWindow:
        ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport, render_arg: *mut c_void)>,
    pub Platform_SwapBuffers:
        ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport, render_arg: *mut c_void)>,
    pub Platform_GetWindowDpiScale: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport) -> f32>,
    pub Platform_OnChangedViewport: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Platform_CreateVkSurface: ::core::option::Option<
        unsafe extern "C" fn(
            vp: *mut ImGuiViewport,
            vk_inst: ImU64,
            vk_allocators: *const c_void,
            out_vk_surface: *mut ImU64,
        ) -> c_int,
    >,
    pub Renderer_CreateWindow: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Renderer_DestroyWindow: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport)>,
    pub Renderer_SetWindowSize: ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport, size: ImVec2)>,
    pub Renderer_RenderWindow:
        ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport, render_arg: *mut c_void)>,
    pub Renderer_SwapBuffers:
        ::core::option::Option<unsafe extern "C" fn(vp: *mut ImGuiViewport, render_arg: *mut c_void)>,
    pub Monitors: ImVector_ImGuiPlatformMonitor,
    pub Viewports: ImVector_ImGuiViewportPtr,
}
impl Default for ImGuiPlatformIO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiPlatformMonitor {
    pub MainPos: ImVec2,
    pub MainSize: ImVec2,
    pub WorkPos: ImVec2,
    pub WorkSize: ImVec2,
    pub DpiScale: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiPlatformImeData {
    pub WantVisible: bool,
    pub InputPos: ImVec2,
    pub InputLineHeight: f32,
}
pub type ImGuiDataAuthority = c_int;
pub type ImGuiLayoutType = c_int;
pub type ImGuiActivateFlags = c_int;
pub type ImGuiDebugLogFlags = c_int;
pub type ImGuiInputFlags = c_int;
pub type ImGuiItemFlags = c_int;
pub type ImGuiItemStatusFlags = c_int;
pub type ImGuiOldColumnFlags = c_int;
pub type ImGuiNavHighlightFlags = c_int;
pub type ImGuiNavMoveFlags = c_int;
pub type ImGuiNextItemDataFlags = c_int;
pub type ImGuiNextWindowDataFlags = c_int;
pub type ImGuiScrollFlags = c_int;
pub type ImGuiSeparatorFlags = c_int;
pub type ImGuiTextFlags = c_int;
pub type ImGuiTooltipFlags = c_int;
pub type ImGuiErrorLogCallback =
    ::core::option::Option<unsafe extern "C" fn(user_data: *mut c_void, fmt: *const c_char, ...)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct StbUndoRecord {
    pub where_: c_int,
    pub insert_length: c_int,
    pub delete_length: c_int,
    pub char_storage: c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct StbUndoState {
    pub undo_rec: [StbUndoRecord; 99usize],
    pub undo_char: [ImWchar; 999usize],
    pub undo_point: c_short,
    pub redo_point: c_short,
    pub undo_char_point: c_int,
    pub redo_char_point: c_int,
}
impl Default for StbUndoState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct STB_TexteditState {
    pub cursor: c_int,
    pub select_start: c_int,
    pub select_end: c_int,
    pub insert_mode: c_uchar,
    pub row_count_per_page: c_int,
    pub cursor_at_end_of_line: c_uchar,
    pub initialized: c_uchar,
    pub has_preferred_x: c_uchar,
    pub single_line: c_uchar,
    pub padding1: c_uchar,
    pub padding2: c_uchar,
    pub padding3: c_uchar,
    pub preferred_x: f32,
    pub undostate: StbUndoState,
}
impl Default for STB_TexteditState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct StbTexteditRow {
    pub x0: f32,
    pub x1: f32,
    pub baseline_y_delta: f32,
    pub ymin: f32,
    pub ymax: f32,
    pub num_chars: c_int,
}
pub type ImFileHandle = *mut FILE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImVec1 {
    pub x: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVec2ih {
    pub x: c_short,
    pub y: c_short,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImRect {
    pub Min: ImVec2,
    pub Max: ImVec2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImBitVector {
    pub Storage: ImVector_ImU32,
}
impl Default for ImBitVector {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ImPoolIdx = c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_int {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut c_int,
}
impl Default for ImVector_int {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiTextIndex {
    pub LineOffsets: ImVector_int,
    pub EndOffset: c_int,
}
impl Default for ImGuiTextIndex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImDrawListSharedData {
    pub TexUvWhitePixel: ImVec2,
    pub Font: *mut ImFont,
    pub FontSize: f32,
    pub CurveTessellationTol: f32,
    pub CircleSegmentMaxError: f32,
    pub ClipRectFullscreen: ImVec4,
    pub InitialFlags: ImDrawListFlags,
    pub TempBuffer: ImVector_ImVec2,
    pub ArcFastVtx: [ImVec2; 48usize],
    pub ArcFastRadiusCutoff: f32,
    pub CircleSegmentCounts: [ImU8; 64usize],
    pub TexUvLines: *const ImVec4,
}
impl Default for ImDrawListSharedData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImDrawListPtr {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut *mut ImDrawList,
}
impl Default for ImVector_ImDrawListPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImDrawDataBuilder {
    pub Layers: [ImVector_ImDrawListPtr; 2usize],
}
impl Default for ImDrawDataBuilder {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImGuiItemFlags_None: ImGuiItemFlags_ = 0;
pub const ImGuiItemFlags_NoTabStop: ImGuiItemFlags_ = 1;
pub const ImGuiItemFlags_ButtonRepeat: ImGuiItemFlags_ = 2;
pub const ImGuiItemFlags_Disabled: ImGuiItemFlags_ = 4;
pub const ImGuiItemFlags_NoNav: ImGuiItemFlags_ = 8;
pub const ImGuiItemFlags_NoNavDefaultFocus: ImGuiItemFlags_ = 16;
pub const ImGuiItemFlags_SelectableDontClosePopup: ImGuiItemFlags_ = 32;
pub const ImGuiItemFlags_MixedValue: ImGuiItemFlags_ = 64;
pub const ImGuiItemFlags_ReadOnly: ImGuiItemFlags_ = 128;
pub const ImGuiItemFlags_NoWindowHoverableCheck: ImGuiItemFlags_ = 256;
pub const ImGuiItemFlags_Inputable: ImGuiItemFlags_ = 1024;
pub type ImGuiItemFlags_ = c_uint;
pub const ImGuiItemStatusFlags_None: ImGuiItemStatusFlags_ = 0;
pub const ImGuiItemStatusFlags_HoveredRect: ImGuiItemStatusFlags_ = 1;
pub const ImGuiItemStatusFlags_HasDisplayRect: ImGuiItemStatusFlags_ = 2;
pub const ImGuiItemStatusFlags_Edited: ImGuiItemStatusFlags_ = 4;
pub const ImGuiItemStatusFlags_ToggledSelection: ImGuiItemStatusFlags_ = 8;
pub const ImGuiItemStatusFlags_ToggledOpen: ImGuiItemStatusFlags_ = 16;
pub const ImGuiItemStatusFlags_HasDeactivated: ImGuiItemStatusFlags_ = 32;
pub const ImGuiItemStatusFlags_Deactivated: ImGuiItemStatusFlags_ = 64;
pub const ImGuiItemStatusFlags_HoveredWindow: ImGuiItemStatusFlags_ = 128;
pub const ImGuiItemStatusFlags_FocusedByTabbing: ImGuiItemStatusFlags_ = 256;
pub const ImGuiItemStatusFlags_Visible: ImGuiItemStatusFlags_ = 512;
pub type ImGuiItemStatusFlags_ = c_uint;
pub const ImGuiInputTextFlags_Multiline: ImGuiInputTextFlagsPrivate_ = 67108864;
pub const ImGuiInputTextFlags_NoMarkEdited: ImGuiInputTextFlagsPrivate_ = 134217728;
pub const ImGuiInputTextFlags_MergedItem: ImGuiInputTextFlagsPrivate_ = 268435456;
pub type ImGuiInputTextFlagsPrivate_ = c_uint;
pub const ImGuiButtonFlags_PressedOnClick: ImGuiButtonFlagsPrivate_ = 16;
pub const ImGuiButtonFlags_PressedOnClickRelease: ImGuiButtonFlagsPrivate_ = 32;
pub const ImGuiButtonFlags_PressedOnClickReleaseAnywhere: ImGuiButtonFlagsPrivate_ = 64;
pub const ImGuiButtonFlags_PressedOnRelease: ImGuiButtonFlagsPrivate_ = 128;
pub const ImGuiButtonFlags_PressedOnDoubleClick: ImGuiButtonFlagsPrivate_ = 256;
pub const ImGuiButtonFlags_PressedOnDragDropHold: ImGuiButtonFlagsPrivate_ = 512;
pub const ImGuiButtonFlags_Repeat: ImGuiButtonFlagsPrivate_ = 1024;
pub const ImGuiButtonFlags_FlattenChildren: ImGuiButtonFlagsPrivate_ = 2048;
pub const ImGuiButtonFlags_AllowItemOverlap: ImGuiButtonFlagsPrivate_ = 4096;
pub const ImGuiButtonFlags_DontClosePopups: ImGuiButtonFlagsPrivate_ = 8192;
pub const ImGuiButtonFlags_AlignTextBaseLine: ImGuiButtonFlagsPrivate_ = 32768;
pub const ImGuiButtonFlags_NoKeyModifiers: ImGuiButtonFlagsPrivate_ = 65536;
pub const ImGuiButtonFlags_NoHoldingActiveId: ImGuiButtonFlagsPrivate_ = 131072;
pub const ImGuiButtonFlags_NoNavFocus: ImGuiButtonFlagsPrivate_ = 262144;
pub const ImGuiButtonFlags_NoHoveredOnFocus: ImGuiButtonFlagsPrivate_ = 524288;
pub const ImGuiButtonFlags_NoSetKeyOwner: ImGuiButtonFlagsPrivate_ = 1048576;
pub const ImGuiButtonFlags_NoTestKeyOwner: ImGuiButtonFlagsPrivate_ = 2097152;
pub const ImGuiButtonFlags_PressedOnMask_: ImGuiButtonFlagsPrivate_ = 1008;
pub const ImGuiButtonFlags_PressedOnDefault_: ImGuiButtonFlagsPrivate_ = 32;
pub type ImGuiButtonFlagsPrivate_ = c_uint;
pub const ImGuiComboFlags_CustomPreview: ImGuiComboFlagsPrivate_ = 1048576;
pub type ImGuiComboFlagsPrivate_ = c_uint;
pub const ImGuiSliderFlags_Vertical: ImGuiSliderFlagsPrivate_ = 1048576;
pub const ImGuiSliderFlags_ReadOnly: ImGuiSliderFlagsPrivate_ = 2097152;
pub type ImGuiSliderFlagsPrivate_ = c_uint;
pub const ImGuiSelectableFlags_NoHoldingActiveID: ImGuiSelectableFlagsPrivate_ = 1048576;
pub const ImGuiSelectableFlags_SelectOnNav: ImGuiSelectableFlagsPrivate_ = 2097152;
pub const ImGuiSelectableFlags_SelectOnClick: ImGuiSelectableFlagsPrivate_ = 4194304;
pub const ImGuiSelectableFlags_SelectOnRelease: ImGuiSelectableFlagsPrivate_ = 8388608;
pub const ImGuiSelectableFlags_SpanAvailWidth: ImGuiSelectableFlagsPrivate_ = 16777216;
pub const ImGuiSelectableFlags_SetNavIdOnHover: ImGuiSelectableFlagsPrivate_ = 33554432;
pub const ImGuiSelectableFlags_NoPadWithHalfSpacing: ImGuiSelectableFlagsPrivate_ = 67108864;
pub const ImGuiSelectableFlags_NoSetKeyOwner: ImGuiSelectableFlagsPrivate_ = 134217728;
pub type ImGuiSelectableFlagsPrivate_ = c_uint;
pub const ImGuiTreeNodeFlags_ClipLabelForTrailingButton: ImGuiTreeNodeFlagsPrivate_ = 1048576;
pub type ImGuiTreeNodeFlagsPrivate_ = c_uint;
pub const ImGuiSeparatorFlags_None: ImGuiSeparatorFlags_ = 0;
pub const ImGuiSeparatorFlags_Horizontal: ImGuiSeparatorFlags_ = 1;
pub const ImGuiSeparatorFlags_Vertical: ImGuiSeparatorFlags_ = 2;
pub const ImGuiSeparatorFlags_SpanAllColumns: ImGuiSeparatorFlags_ = 4;
pub type ImGuiSeparatorFlags_ = c_uint;
pub const ImGuiTextFlags_None: ImGuiTextFlags_ = 0;
pub const ImGuiTextFlags_NoWidthForLargeClippedText: ImGuiTextFlags_ = 1;
pub type ImGuiTextFlags_ = c_uint;
pub const ImGuiTooltipFlags_None: ImGuiTooltipFlags_ = 0;
pub const ImGuiTooltipFlags_OverridePreviousTooltip: ImGuiTooltipFlags_ = 1;
pub type ImGuiTooltipFlags_ = c_uint;
pub const ImGuiLayoutType_Horizontal: ImGuiLayoutType_ = 0;
pub const ImGuiLayoutType_Vertical: ImGuiLayoutType_ = 1;
pub type ImGuiLayoutType_ = c_uint;
pub const ImGuiLogType_None: ImGuiLogType = 0;
pub const ImGuiLogType_TTY: ImGuiLogType = 1;
pub const ImGuiLogType_File: ImGuiLogType = 2;
pub const ImGuiLogType_Buffer: ImGuiLogType = 3;
pub const ImGuiLogType_Clipboard: ImGuiLogType = 4;
pub type ImGuiLogType = c_uint;
pub const ImGuiAxis_None: ImGuiAxis = -1;
pub const ImGuiAxis_X: ImGuiAxis = 0;
pub const ImGuiAxis_Y: ImGuiAxis = 1;
pub type ImGuiAxis = c_int;
pub const ImGuiPlotType_Lines: ImGuiPlotType = 0;
pub const ImGuiPlotType_Histogram: ImGuiPlotType = 1;
pub type ImGuiPlotType = c_uint;
pub const ImGuiPopupPositionPolicy_Default: ImGuiPopupPositionPolicy = 0;
pub const ImGuiPopupPositionPolicy_ComboBox: ImGuiPopupPositionPolicy = 1;
pub const ImGuiPopupPositionPolicy_Tooltip: ImGuiPopupPositionPolicy = 2;
pub type ImGuiPopupPositionPolicy = c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiDataTypeTempStorage {
    pub Data: [ImU8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiDataTypeInfo {
    pub Size: usize,
    pub Name: *const c_char,
    pub PrintFmt: *const c_char,
    pub ScanFmt: *const c_char,
}
impl Default for ImGuiDataTypeInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImGuiDataType_String: ImGuiDataTypePrivate_ = 11;
pub const ImGuiDataType_Pointer: ImGuiDataTypePrivate_ = 12;
pub const ImGuiDataType_ID: ImGuiDataTypePrivate_ = 13;
pub type ImGuiDataTypePrivate_ = c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiColorMod {
    pub Col: ImGuiCol,
    pub BackupValue: ImVec4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImGuiStyleMod {
    pub VarIdx: ImGuiStyleVar,
    pub __bindgen_anon_1: ImGuiStyleMod__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ImGuiStyleMod__bindgen_ty_1 {
    pub BackupInt: [c_int; 2usize],
    pub BackupFloat: [f32; 2usize],
}
impl Default for ImGuiStyleMod__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for ImGuiStyleMod__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "ImGuiStyleMod__bindgen_ty_1 {{ union }}")
    }
}
impl Default for ImGuiStyleMod {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for ImGuiStyleMod {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "ImGuiStyleMod {{ VarIdx: {:?}, __bindgen_anon_1: {:?} }}", self.VarIdx, self.__bindgen_anon_1)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiComboPreviewData {
    pub PreviewRect: ImRect,
    pub BackupCursorPos: ImVec2,
    pub BackupCursorMaxPos: ImVec2,
    pub BackupCursorPosPrevLine: ImVec2,
    pub BackupPrevLineTextBaseOffset: f32,
    pub BackupLayout: ImGuiLayoutType,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiGroupData {
    pub WindowID: ImGuiID,
    pub BackupCursorPos: ImVec2,
    pub BackupCursorMaxPos: ImVec2,
    pub BackupIndent: ImVec1,
    pub BackupGroupOffset: ImVec1,
    pub BackupCurrLineSize: ImVec2,
    pub BackupCurrLineTextBaseOffset: f32,
    pub BackupActiveIdIsAlive: ImGuiID,
    pub BackupActiveIdPreviousFrameIsAlive: bool,
    pub BackupHoveredIdIsAlive: bool,
    pub EmitItem: bool,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiMenuColumns {
    pub TotalWidth: ImU32,
    pub NextTotalWidth: ImU32,
    pub Spacing: ImU16,
    pub OffsetIcon: ImU16,
    pub OffsetLabel: ImU16,
    pub OffsetShortcut: ImU16,
    pub OffsetMark: ImU16,
    pub Widths: [ImU16; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiInputTextState {
    pub Ctx: *mut ImGuiContext,
    pub ID: ImGuiID,
    pub CurLenW: c_int,
    pub CurLenA: c_int,
    pub TextW: ImVector_ImWchar,
    pub TextA: ImVector_char,
    pub InitialTextA: ImVector_char,
    pub TextAIsValid: bool,
    pub BufCapacityA: c_int,
    pub ScrollX: f32,
    pub Stb: STB_TexteditState,
    pub CursorAnim: f32,
    pub CursorFollow: bool,
    pub SelectedAllMouseLock: bool,
    pub Edited: bool,
    pub Flags: ImGuiInputTextFlags,
}
impl Default for ImGuiInputTextState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiPopupData {
    pub PopupId: ImGuiID,
    pub Window: *mut ImGuiWindow,
    pub BackupNavWindow: *mut ImGuiWindow,
    pub ParentNavLayer: c_int,
    pub OpenFrameCount: c_int,
    pub OpenParentId: ImGuiID,
    pub OpenPopupPos: ImVec2,
    pub OpenMousePos: ImVec2,
}
impl Default for ImGuiPopupData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImGuiNextWindowDataFlags_None: ImGuiNextWindowDataFlags_ = 0;
pub const ImGuiNextWindowDataFlags_HasPos: ImGuiNextWindowDataFlags_ = 1;
pub const ImGuiNextWindowDataFlags_HasSize: ImGuiNextWindowDataFlags_ = 2;
pub const ImGuiNextWindowDataFlags_HasContentSize: ImGuiNextWindowDataFlags_ = 4;
pub const ImGuiNextWindowDataFlags_HasCollapsed: ImGuiNextWindowDataFlags_ = 8;
pub const ImGuiNextWindowDataFlags_HasSizeConstraint: ImGuiNextWindowDataFlags_ = 16;
pub const ImGuiNextWindowDataFlags_HasFocus: ImGuiNextWindowDataFlags_ = 32;
pub const ImGuiNextWindowDataFlags_HasBgAlpha: ImGuiNextWindowDataFlags_ = 64;
pub const ImGuiNextWindowDataFlags_HasScroll: ImGuiNextWindowDataFlags_ = 128;
pub const ImGuiNextWindowDataFlags_HasViewport: ImGuiNextWindowDataFlags_ = 256;
pub const ImGuiNextWindowDataFlags_HasDock: ImGuiNextWindowDataFlags_ = 512;
pub const ImGuiNextWindowDataFlags_HasWindowClass: ImGuiNextWindowDataFlags_ = 1024;
pub type ImGuiNextWindowDataFlags_ = c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiNextWindowData {
    pub Flags: ImGuiNextWindowDataFlags,
    pub PosCond: ImGuiCond,
    pub SizeCond: ImGuiCond,
    pub CollapsedCond: ImGuiCond,
    pub DockCond: ImGuiCond,
    pub PosVal: ImVec2,
    pub PosPivotVal: ImVec2,
    pub SizeVal: ImVec2,
    pub ContentSizeVal: ImVec2,
    pub ScrollVal: ImVec2,
    pub PosUndock: bool,
    pub CollapsedVal: bool,
    pub SizeConstraintRect: ImRect,
    pub SizeCallback: ImGuiSizeCallback,
    pub SizeCallbackUserData: *mut c_void,
    pub BgAlphaVal: f32,
    pub ViewportId: ImGuiID,
    pub DockId: ImGuiID,
    pub WindowClass: ImGuiWindowClass,
    pub MenuBarOffsetMinVal: ImVec2,
}
impl Default for ImGuiNextWindowData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImGuiNextItemDataFlags_None: ImGuiNextItemDataFlags_ = 0;
pub const ImGuiNextItemDataFlags_HasWidth: ImGuiNextItemDataFlags_ = 1;
pub const ImGuiNextItemDataFlags_HasOpen: ImGuiNextItemDataFlags_ = 2;
pub type ImGuiNextItemDataFlags_ = c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiNextItemData {
    pub Flags: ImGuiNextItemDataFlags,
    pub Width: f32,
    pub FocusScopeId: ImGuiID,
    pub OpenCond: ImGuiCond,
    pub OpenVal: bool,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiLastItemData {
    pub ID: ImGuiID,
    pub InFlags: ImGuiItemFlags,
    pub StatusFlags: ImGuiItemStatusFlags,
    pub Rect: ImRect,
    pub NavRect: ImRect,
    pub DisplayRect: ImRect,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiStackSizes {
    pub SizeOfIDStack: c_short,
    pub SizeOfColorStack: c_short,
    pub SizeOfStyleVarStack: c_short,
    pub SizeOfFontStack: c_short,
    pub SizeOfFocusScopeStack: c_short,
    pub SizeOfGroupStack: c_short,
    pub SizeOfItemFlagsStack: c_short,
    pub SizeOfBeginPopupStack: c_short,
    pub SizeOfDisabledStack: c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiWindowStackData {
    pub Window: *mut ImGuiWindow,
    pub ParentLastItemDataBackup: ImGuiLastItemData,
    pub StackSizesOnBegin: ImGuiStackSizes,
}
impl Default for ImGuiWindowStackData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiShrinkWidthItem {
    pub Index: c_int,
    pub Width: f32,
    pub InitialWidth: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiPtrOrIndex {
    pub Ptr: *mut c_void,
    pub Index: c_int,
}
impl Default for ImGuiPtrOrIndex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImGuiInputEventType_None: ImGuiInputEventType = 0;
pub const ImGuiInputEventType_MousePos: ImGuiInputEventType = 1;
pub const ImGuiInputEventType_MouseWheel: ImGuiInputEventType = 2;
pub const ImGuiInputEventType_MouseButton: ImGuiInputEventType = 3;
pub const ImGuiInputEventType_MouseViewport: ImGuiInputEventType = 4;
pub const ImGuiInputEventType_Key: ImGuiInputEventType = 5;
pub const ImGuiInputEventType_Text: ImGuiInputEventType = 6;
pub const ImGuiInputEventType_Focus: ImGuiInputEventType = 7;
pub const ImGuiInputEventType_COUNT: ImGuiInputEventType = 8;
pub type ImGuiInputEventType = c_uint;
pub const ImGuiInputSource_None: ImGuiInputSource = 0;
pub const ImGuiInputSource_Mouse: ImGuiInputSource = 1;
pub const ImGuiInputSource_Keyboard: ImGuiInputSource = 2;
pub const ImGuiInputSource_Gamepad: ImGuiInputSource = 3;
pub const ImGuiInputSource_Clipboard: ImGuiInputSource = 4;
pub const ImGuiInputSource_Nav: ImGuiInputSource = 5;
pub const ImGuiInputSource_COUNT: ImGuiInputSource = 6;
pub type ImGuiInputSource = c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiInputEventMousePos {
    pub PosX: f32,
    pub PosY: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiInputEventMouseWheel {
    pub WheelX: f32,
    pub WheelY: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiInputEventMouseButton {
    pub Button: c_int,
    pub Down: bool,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiInputEventMouseViewport {
    pub HoveredViewportID: ImGuiID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiInputEventKey {
    pub Key: ImGuiKey,
    pub Down: bool,
    pub AnalogValue: f32,
}
impl Default for ImGuiInputEventKey {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiInputEventText {
    pub Char: c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiInputEventAppFocused {
    pub Focused: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ImGuiInputEvent {
    pub Type: ImGuiInputEventType,
    pub Source: ImGuiInputSource,
    pub __bindgen_anon_1: ImGuiInputEvent__bindgen_ty_1,
    pub AddedByTestEngine: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ImGuiInputEvent__bindgen_ty_1 {
    pub MousePos: ImGuiInputEventMousePos,
    pub MouseWheel: ImGuiInputEventMouseWheel,
    pub MouseButton: ImGuiInputEventMouseButton,
    pub MouseViewport: ImGuiInputEventMouseViewport,
    pub Key: ImGuiInputEventKey,
    pub Text: ImGuiInputEventText,
    pub AppFocused: ImGuiInputEventAppFocused,
}
impl Default for ImGuiInputEvent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for ImGuiInputEvent__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "ImGuiInputEvent__bindgen_ty_1 {{ union }}")
    }
}
impl Default for ImGuiInputEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for ImGuiInputEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "ImGuiInputEvent {{ Type: {:?}, Source: {:?}, __bindgen_anon_1: {:?}, AddedByTestEngine: {:?} }}",
            self.Type, self.Source, self.__bindgen_anon_1, self.AddedByTestEngine
        )
    }
}
pub type ImGuiKeyRoutingIndex = ImS16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiKeyRoutingData {
    pub NextEntryIndex: ImGuiKeyRoutingIndex,
    pub Mods: ImU16,
    pub RoutingNextScore: ImU8,
    pub RoutingCurr: ImGuiID,
    pub RoutingNext: ImGuiID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiKeyRoutingData {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiKeyRoutingData,
}
impl Default for ImVector_ImGuiKeyRoutingData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiKeyRoutingTable {
    pub Index: [ImGuiKeyRoutingIndex; 140usize],
    pub Entries: ImVector_ImGuiKeyRoutingData,
    pub EntriesNext: ImVector_ImGuiKeyRoutingData,
}
impl Default for ImGuiKeyRoutingTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiKeyOwnerData {
    pub OwnerCurr: ImGuiID,
    pub OwnerNext: ImGuiID,
    pub LockThisFrame: bool,
    pub LockUntilRelease: bool,
}
pub const ImGuiInputFlags_None: ImGuiInputFlags_ = 0;
pub const ImGuiInputFlags_Repeat: ImGuiInputFlags_ = 1;
pub const ImGuiInputFlags_RepeatRateDefault: ImGuiInputFlags_ = 2;
pub const ImGuiInputFlags_RepeatRateNavMove: ImGuiInputFlags_ = 4;
pub const ImGuiInputFlags_RepeatRateNavTweak: ImGuiInputFlags_ = 8;
pub const ImGuiInputFlags_RepeatRateMask_: ImGuiInputFlags_ = 14;
pub const ImGuiInputFlags_CondHovered: ImGuiInputFlags_ = 16;
pub const ImGuiInputFlags_CondActive: ImGuiInputFlags_ = 32;
pub const ImGuiInputFlags_CondDefault_: ImGuiInputFlags_ = 48;
pub const ImGuiInputFlags_CondMask_: ImGuiInputFlags_ = 48;
pub const ImGuiInputFlags_LockThisFrame: ImGuiInputFlags_ = 64;
pub const ImGuiInputFlags_LockUntilRelease: ImGuiInputFlags_ = 128;
pub const ImGuiInputFlags_RouteFocused: ImGuiInputFlags_ = 256;
pub const ImGuiInputFlags_RouteGlobalLow: ImGuiInputFlags_ = 512;
pub const ImGuiInputFlags_RouteGlobal: ImGuiInputFlags_ = 1024;
pub const ImGuiInputFlags_RouteGlobalHigh: ImGuiInputFlags_ = 2048;
pub const ImGuiInputFlags_RouteMask_: ImGuiInputFlags_ = 3840;
pub const ImGuiInputFlags_RouteAlways: ImGuiInputFlags_ = 4096;
pub const ImGuiInputFlags_RouteUnlessBgFocused: ImGuiInputFlags_ = 8192;
pub const ImGuiInputFlags_RouteExtraMask_: ImGuiInputFlags_ = 12288;
pub const ImGuiInputFlags_SupportedByIsKeyPressed: ImGuiInputFlags_ = 15;
pub const ImGuiInputFlags_SupportedByShortcut: ImGuiInputFlags_ = 16143;
pub const ImGuiInputFlags_SupportedBySetKeyOwner: ImGuiInputFlags_ = 192;
pub const ImGuiInputFlags_SupportedBySetItemKeyOwner: ImGuiInputFlags_ = 240;
pub type ImGuiInputFlags_ = c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiListClipperRange {
    pub Min: c_int,
    pub Max: c_int,
    pub PosToIndexConvert: bool,
    pub PosToIndexOffsetMin: ImS8,
    pub PosToIndexOffsetMax: ImS8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiListClipperRange {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiListClipperRange,
}
impl Default for ImVector_ImGuiListClipperRange {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiListClipperData {
    pub ListClipper: *mut ImGuiListClipper,
    pub LossynessOffset: f32,
    pub StepNo: c_int,
    pub ItemsFrozen: c_int,
    pub Ranges: ImVector_ImGuiListClipperRange,
}
impl Default for ImGuiListClipperData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImGuiActivateFlags_None: ImGuiActivateFlags_ = 0;
pub const ImGuiActivateFlags_PreferInput: ImGuiActivateFlags_ = 1;
pub const ImGuiActivateFlags_PreferTweak: ImGuiActivateFlags_ = 2;
pub const ImGuiActivateFlags_TryToPreserveState: ImGuiActivateFlags_ = 4;
pub type ImGuiActivateFlags_ = c_uint;
pub const ImGuiScrollFlags_None: ImGuiScrollFlags_ = 0;
pub const ImGuiScrollFlags_KeepVisibleEdgeX: ImGuiScrollFlags_ = 1;
pub const ImGuiScrollFlags_KeepVisibleEdgeY: ImGuiScrollFlags_ = 2;
pub const ImGuiScrollFlags_KeepVisibleCenterX: ImGuiScrollFlags_ = 4;
pub const ImGuiScrollFlags_KeepVisibleCenterY: ImGuiScrollFlags_ = 8;
pub const ImGuiScrollFlags_AlwaysCenterX: ImGuiScrollFlags_ = 16;
pub const ImGuiScrollFlags_AlwaysCenterY: ImGuiScrollFlags_ = 32;
pub const ImGuiScrollFlags_NoScrollParent: ImGuiScrollFlags_ = 64;
pub const ImGuiScrollFlags_MaskX_: ImGuiScrollFlags_ = 21;
pub const ImGuiScrollFlags_MaskY_: ImGuiScrollFlags_ = 42;
pub type ImGuiScrollFlags_ = c_uint;
pub const ImGuiNavHighlightFlags_None: ImGuiNavHighlightFlags_ = 0;
pub const ImGuiNavHighlightFlags_TypeDefault: ImGuiNavHighlightFlags_ = 1;
pub const ImGuiNavHighlightFlags_TypeThin: ImGuiNavHighlightFlags_ = 2;
pub const ImGuiNavHighlightFlags_AlwaysDraw: ImGuiNavHighlightFlags_ = 4;
pub const ImGuiNavHighlightFlags_NoRounding: ImGuiNavHighlightFlags_ = 8;
pub type ImGuiNavHighlightFlags_ = c_uint;
pub const ImGuiNavMoveFlags_None: ImGuiNavMoveFlags_ = 0;
pub const ImGuiNavMoveFlags_LoopX: ImGuiNavMoveFlags_ = 1;
pub const ImGuiNavMoveFlags_LoopY: ImGuiNavMoveFlags_ = 2;
pub const ImGuiNavMoveFlags_WrapX: ImGuiNavMoveFlags_ = 4;
pub const ImGuiNavMoveFlags_WrapY: ImGuiNavMoveFlags_ = 8;
pub const ImGuiNavMoveFlags_AllowCurrentNavId: ImGuiNavMoveFlags_ = 16;
pub const ImGuiNavMoveFlags_AlsoScoreVisibleSet: ImGuiNavMoveFlags_ = 32;
pub const ImGuiNavMoveFlags_ScrollToEdgeY: ImGuiNavMoveFlags_ = 64;
pub const ImGuiNavMoveFlags_Forwarded: ImGuiNavMoveFlags_ = 128;
pub const ImGuiNavMoveFlags_DebugNoResult: ImGuiNavMoveFlags_ = 256;
pub const ImGuiNavMoveFlags_FocusApi: ImGuiNavMoveFlags_ = 512;
pub const ImGuiNavMoveFlags_Tabbing: ImGuiNavMoveFlags_ = 1024;
pub const ImGuiNavMoveFlags_Activate: ImGuiNavMoveFlags_ = 2048;
pub const ImGuiNavMoveFlags_DontSetNavHighlight: ImGuiNavMoveFlags_ = 4096;
pub type ImGuiNavMoveFlags_ = c_uint;
pub const ImGuiNavLayer_Main: ImGuiNavLayer = 0;
pub const ImGuiNavLayer_Menu: ImGuiNavLayer = 1;
pub const ImGuiNavLayer_COUNT: ImGuiNavLayer = 2;
pub type ImGuiNavLayer = c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiNavItemData {
    pub Window: *mut ImGuiWindow,
    pub ID: ImGuiID,
    pub FocusScopeId: ImGuiID,
    pub RectRel: ImRect,
    pub InFlags: ImGuiItemFlags,
    pub DistBox: f32,
    pub DistCenter: f32,
    pub DistAxial: f32,
}
impl Default for ImGuiNavItemData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImGuiOldColumnFlags_None: ImGuiOldColumnFlags_ = 0;
pub const ImGuiOldColumnFlags_NoBorder: ImGuiOldColumnFlags_ = 1;
pub const ImGuiOldColumnFlags_NoResize: ImGuiOldColumnFlags_ = 2;
pub const ImGuiOldColumnFlags_NoPreserveWidths: ImGuiOldColumnFlags_ = 4;
pub const ImGuiOldColumnFlags_NoForceWithinWindow: ImGuiOldColumnFlags_ = 8;
pub const ImGuiOldColumnFlags_GrowParentContentsSize: ImGuiOldColumnFlags_ = 16;
pub type ImGuiOldColumnFlags_ = c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiOldColumnData {
    pub OffsetNorm: f32,
    pub OffsetNormBeforeResize: f32,
    pub Flags: ImGuiOldColumnFlags,
    pub ClipRect: ImRect,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiOldColumnData {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiOldColumnData,
}
impl Default for ImVector_ImGuiOldColumnData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiOldColumns {
    pub ID: ImGuiID,
    pub Flags: ImGuiOldColumnFlags,
    pub IsFirstFrame: bool,
    pub IsBeingResized: bool,
    pub Current: c_int,
    pub Count: c_int,
    pub OffMinX: f32,
    pub OffMaxX: f32,
    pub LineMinY: f32,
    pub LineMaxY: f32,
    pub HostCursorPosY: f32,
    pub HostCursorMaxPosX: f32,
    pub HostInitialClipRect: ImRect,
    pub HostBackupClipRect: ImRect,
    pub HostBackupParentWorkRect: ImRect,
    pub Columns: ImVector_ImGuiOldColumnData,
    pub Splitter: ImDrawListSplitter,
}
impl Default for ImGuiOldColumns {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImGuiDockNodeFlags_DockSpace: ImGuiDockNodeFlagsPrivate_ = 1024;
pub const ImGuiDockNodeFlags_CentralNode: ImGuiDockNodeFlagsPrivate_ = 2048;
pub const ImGuiDockNodeFlags_NoTabBar: ImGuiDockNodeFlagsPrivate_ = 4096;
pub const ImGuiDockNodeFlags_HiddenTabBar: ImGuiDockNodeFlagsPrivate_ = 8192;
pub const ImGuiDockNodeFlags_NoWindowMenuButton: ImGuiDockNodeFlagsPrivate_ = 16384;
pub const ImGuiDockNodeFlags_NoCloseButton: ImGuiDockNodeFlagsPrivate_ = 32768;
pub const ImGuiDockNodeFlags_NoDocking: ImGuiDockNodeFlagsPrivate_ = 65536;
pub const ImGuiDockNodeFlags_NoDockingSplitMe: ImGuiDockNodeFlagsPrivate_ = 131072;
pub const ImGuiDockNodeFlags_NoDockingSplitOther: ImGuiDockNodeFlagsPrivate_ = 262144;
pub const ImGuiDockNodeFlags_NoDockingOverMe: ImGuiDockNodeFlagsPrivate_ = 524288;
pub const ImGuiDockNodeFlags_NoDockingOverOther: ImGuiDockNodeFlagsPrivate_ = 1048576;
pub const ImGuiDockNodeFlags_NoDockingOverEmpty: ImGuiDockNodeFlagsPrivate_ = 2097152;
pub const ImGuiDockNodeFlags_NoResizeX: ImGuiDockNodeFlagsPrivate_ = 4194304;
pub const ImGuiDockNodeFlags_NoResizeY: ImGuiDockNodeFlagsPrivate_ = 8388608;
pub const ImGuiDockNodeFlags_SharedFlagsInheritMask_: ImGuiDockNodeFlagsPrivate_ = -1;
pub const ImGuiDockNodeFlags_NoResizeFlagsMask_: ImGuiDockNodeFlagsPrivate_ = 12582944;
pub const ImGuiDockNodeFlags_LocalFlagsMask_: ImGuiDockNodeFlagsPrivate_ = 12713072;
pub const ImGuiDockNodeFlags_LocalFlagsTransferMask_: ImGuiDockNodeFlagsPrivate_ = 12712048;
pub const ImGuiDockNodeFlags_SavedFlagsMask_: ImGuiDockNodeFlagsPrivate_ = 12712992;
pub type ImGuiDockNodeFlagsPrivate_ = c_int;
pub const ImGuiDataAuthority_Auto: ImGuiDataAuthority_ = 0;
pub const ImGuiDataAuthority_DockNode: ImGuiDataAuthority_ = 1;
pub const ImGuiDataAuthority_Window: ImGuiDataAuthority_ = 2;
pub type ImGuiDataAuthority_ = c_uint;
pub const ImGuiDockNodeState_Unknown: ImGuiDockNodeState = 0;
pub const ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow: ImGuiDockNodeState = 1;
pub const ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing: ImGuiDockNodeState = 2;
pub const ImGuiDockNodeState_HostWindowVisible: ImGuiDockNodeState = 3;
pub type ImGuiDockNodeState = c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiWindowPtr {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut *mut ImGuiWindow,
}
impl Default for ImVector_ImGuiWindowPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiDockNode {
    pub ID: ImGuiID,
    pub SharedFlags: ImGuiDockNodeFlags,
    pub LocalFlags: ImGuiDockNodeFlags,
    pub LocalFlagsInWindows: ImGuiDockNodeFlags,
    pub MergedFlags: ImGuiDockNodeFlags,
    pub State: ImGuiDockNodeState,
    pub ParentNode: *mut ImGuiDockNode,
    pub ChildNodes: [*mut ImGuiDockNode; 2usize],
    pub Windows: ImVector_ImGuiWindowPtr,
    pub TabBar: *mut ImGuiTabBar,
    pub Pos: ImVec2,
    pub Size: ImVec2,
    pub SizeRef: ImVec2,
    pub SplitAxis: ImGuiAxis,
    pub WindowClass: ImGuiWindowClass,
    pub LastBgColor: ImU32,
    pub HostWindow: *mut ImGuiWindow,
    pub VisibleWindow: *mut ImGuiWindow,
    pub CentralNode: *mut ImGuiDockNode,
    pub OnlyNodeWithWindows: *mut ImGuiDockNode,
    pub CountNodeWithWindows: c_int,
    pub LastFrameAlive: c_int,
    pub LastFrameActive: c_int,
    pub LastFrameFocused: c_int,
    pub LastFocusedNodeId: ImGuiID,
    pub SelectedTabId: ImGuiID,
    pub WantCloseTabId: ImGuiID,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl Default for ImGuiDockNode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ImGuiDockNode {
    #[inline]
    pub fn AuthorityForPos(&self) -> ImGuiDataAuthority {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_AuthorityForPos(&mut self, val: ImGuiDataAuthority) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn AuthorityForSize(&self) -> ImGuiDataAuthority {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_AuthorityForSize(&mut self, val: ImGuiDataAuthority) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn AuthorityForViewport(&self) -> ImGuiDataAuthority {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_AuthorityForViewport(&mut self, val: ImGuiDataAuthority) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn IsVisible(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsVisible(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsFocused(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsFocused(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsBgDrawnThisFrame(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsBgDrawnThisFrame(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasCloseButton(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HasCloseButton(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasWindowMenuButton(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HasWindowMenuButton(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasCentralNodeChild(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HasCentralNodeChild(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WantCloseAll(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WantCloseAll(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WantLockSizeOnce(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WantLockSizeOnce(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WantMouseMove(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WantMouseMove(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WantHiddenTabBarUpdate(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WantHiddenTabBarUpdate(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WantHiddenTabBarToggle(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WantHiddenTabBarToggle(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AuthorityForPos: ImGuiDataAuthority,
        AuthorityForSize: ImGuiDataAuthority,
        AuthorityForViewport: ImGuiDataAuthority,
        IsVisible: bool,
        IsFocused: bool,
        IsBgDrawnThisFrame: bool,
        HasCloseButton: bool,
        HasWindowMenuButton: bool,
        HasCentralNodeChild: bool,
        WantCloseAll: bool,
        WantLockSizeOnce: bool,
        WantMouseMove: bool,
        WantHiddenTabBarUpdate: bool,
        WantHiddenTabBarToggle: bool,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let AuthorityForPos: u32 = unsafe { ::core::mem::transmute(AuthorityForPos) };
            AuthorityForPos as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let AuthorityForSize: u32 = unsafe { ::core::mem::transmute(AuthorityForSize) };
            AuthorityForSize as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let AuthorityForViewport: u32 = unsafe { ::core::mem::transmute(AuthorityForViewport) };
            AuthorityForViewport as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let IsVisible: u8 = unsafe { ::core::mem::transmute(IsVisible) };
            IsVisible as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let IsFocused: u8 = unsafe { ::core::mem::transmute(IsFocused) };
            IsFocused as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let IsBgDrawnThisFrame: u8 = unsafe { ::core::mem::transmute(IsBgDrawnThisFrame) };
            IsBgDrawnThisFrame as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let HasCloseButton: u8 = unsafe { ::core::mem::transmute(HasCloseButton) };
            HasCloseButton as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let HasWindowMenuButton: u8 = unsafe { ::core::mem::transmute(HasWindowMenuButton) };
            HasWindowMenuButton as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let HasCentralNodeChild: u8 = unsafe { ::core::mem::transmute(HasCentralNodeChild) };
            HasCentralNodeChild as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let WantCloseAll: u8 = unsafe { ::core::mem::transmute(WantCloseAll) };
            WantCloseAll as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let WantLockSizeOnce: u8 = unsafe { ::core::mem::transmute(WantLockSizeOnce) };
            WantLockSizeOnce as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let WantMouseMove: u8 = unsafe { ::core::mem::transmute(WantMouseMove) };
            WantMouseMove as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let WantHiddenTabBarUpdate: u8 = unsafe { ::core::mem::transmute(WantHiddenTabBarUpdate) };
            WantHiddenTabBarUpdate as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let WantHiddenTabBarToggle: u8 = unsafe { ::core::mem::transmute(WantHiddenTabBarToggle) };
            WantHiddenTabBarToggle as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const ImGuiWindowDockStyleCol_Text: ImGuiWindowDockStyleCol = 0;
pub const ImGuiWindowDockStyleCol_Tab: ImGuiWindowDockStyleCol = 1;
pub const ImGuiWindowDockStyleCol_TabHovered: ImGuiWindowDockStyleCol = 2;
pub const ImGuiWindowDockStyleCol_TabActive: ImGuiWindowDockStyleCol = 3;
pub const ImGuiWindowDockStyleCol_TabUnfocused: ImGuiWindowDockStyleCol = 4;
pub const ImGuiWindowDockStyleCol_TabUnfocusedActive: ImGuiWindowDockStyleCol = 5;
pub const ImGuiWindowDockStyleCol_COUNT: ImGuiWindowDockStyleCol = 6;
pub type ImGuiWindowDockStyleCol = c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiWindowDockStyle {
    pub Colors: [ImU32; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiDockRequest {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiDockRequest,
}
impl Default for ImVector_ImGuiDockRequest {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiDockNodeSettings {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiDockNodeSettings,
}
impl Default for ImVector_ImGuiDockNodeSettings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiDockContext {
    pub Nodes: ImGuiStorage,
    pub Requests: ImVector_ImGuiDockRequest,
    pub NodesSettings: ImVector_ImGuiDockNodeSettings,
    pub WantFullRebuild: bool,
}
impl Default for ImGuiDockContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiViewportP {
    pub _ImGuiViewport: ImGuiViewport,
    pub Idx: c_int,
    pub LastFrameActive: c_int,
    pub LastFrontMostStampCount: c_int,
    pub LastNameHash: ImGuiID,
    pub LastPos: ImVec2,
    pub Alpha: f32,
    pub LastAlpha: f32,
    pub PlatformMonitor: c_short,
    pub Window: *mut ImGuiWindow,
    pub DrawListsLastFrame: [c_int; 2usize],
    pub DrawLists: [*mut ImDrawList; 2usize],
    pub DrawDataP: ImDrawData,
    pub DrawDataBuilder: ImDrawDataBuilder,
    pub LastPlatformPos: ImVec2,
    pub LastPlatformSize: ImVec2,
    pub LastRendererSize: ImVec2,
    pub WorkOffsetMin: ImVec2,
    pub WorkOffsetMax: ImVec2,
    pub BuildWorkOffsetMin: ImVec2,
    pub BuildWorkOffsetMax: ImVec2,
}
impl Default for ImGuiViewportP {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiWindowSettings {
    pub ID: ImGuiID,
    pub Pos: ImVec2ih,
    pub Size: ImVec2ih,
    pub ViewportPos: ImVec2ih,
    pub ViewportId: ImGuiID,
    pub DockId: ImGuiID,
    pub ClassId: ImGuiID,
    pub DockOrder: c_short,
    pub Collapsed: bool,
    pub WantApply: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiSettingsHandler {
    pub TypeName: *const c_char,
    pub TypeHash: ImGuiID,
    pub ClearAllFn:
        ::core::option::Option<unsafe extern "C" fn(ctx: *mut ImGuiContext, handler: *mut ImGuiSettingsHandler)>,
    pub ReadInitFn:
        ::core::option::Option<unsafe extern "C" fn(ctx: *mut ImGuiContext, handler: *mut ImGuiSettingsHandler)>,
    pub ReadOpenFn: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ImGuiContext,
            handler: *mut ImGuiSettingsHandler,
            name: *const c_char,
        ) -> *mut c_void,
    >,
    pub ReadLineFn: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ImGuiContext,
            handler: *mut ImGuiSettingsHandler,
            entry: *mut c_void,
            line: *const c_char,
        ),
    >,
    pub ApplyAllFn:
        ::core::option::Option<unsafe extern "C" fn(ctx: *mut ImGuiContext, handler: *mut ImGuiSettingsHandler)>,
    pub WriteAllFn: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut ImGuiContext, handler: *mut ImGuiSettingsHandler, out_buf: *mut ImGuiTextBuffer),
    >,
    pub UserData: *mut c_void,
}
impl Default for ImGuiSettingsHandler {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImGuiLocKey_TableSizeOne: ImGuiLocKey = 0;
pub const ImGuiLocKey_TableSizeAllFit: ImGuiLocKey = 1;
pub const ImGuiLocKey_TableSizeAllDefault: ImGuiLocKey = 2;
pub const ImGuiLocKey_TableResetOrder: ImGuiLocKey = 3;
pub const ImGuiLocKey_WindowingMainMenuBar: ImGuiLocKey = 4;
pub const ImGuiLocKey_WindowingPopup: ImGuiLocKey = 5;
pub const ImGuiLocKey_WindowingUntitled: ImGuiLocKey = 6;
pub const ImGuiLocKey_DockingHideTabBar: ImGuiLocKey = 7;
pub const ImGuiLocKey_COUNT: ImGuiLocKey = 8;
pub type ImGuiLocKey = c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiLocEntry {
    pub Key: ImGuiLocKey,
    pub Text: *const c_char,
}
impl Default for ImGuiLocEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImGuiDebugLogFlags_None: ImGuiDebugLogFlags_ = 0;
pub const ImGuiDebugLogFlags_EventActiveId: ImGuiDebugLogFlags_ = 1;
pub const ImGuiDebugLogFlags_EventFocus: ImGuiDebugLogFlags_ = 2;
pub const ImGuiDebugLogFlags_EventPopup: ImGuiDebugLogFlags_ = 4;
pub const ImGuiDebugLogFlags_EventNav: ImGuiDebugLogFlags_ = 8;
pub const ImGuiDebugLogFlags_EventClipper: ImGuiDebugLogFlags_ = 16;
pub const ImGuiDebugLogFlags_EventIO: ImGuiDebugLogFlags_ = 32;
pub const ImGuiDebugLogFlags_EventDocking: ImGuiDebugLogFlags_ = 64;
pub const ImGuiDebugLogFlags_EventViewport: ImGuiDebugLogFlags_ = 128;
pub const ImGuiDebugLogFlags_EventMask_: ImGuiDebugLogFlags_ = 255;
pub const ImGuiDebugLogFlags_OutputToTTY: ImGuiDebugLogFlags_ = 1024;
pub type ImGuiDebugLogFlags_ = c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiMetricsConfig {
    pub ShowDebugLog: bool,
    pub ShowStackTool: bool,
    pub ShowWindowsRects: bool,
    pub ShowWindowsBeginOrder: bool,
    pub ShowTablesRects: bool,
    pub ShowDrawCmdMesh: bool,
    pub ShowDrawCmdBoundingBoxes: bool,
    pub ShowDockingNodes: bool,
    pub ShowWindowsRectsType: c_int,
    pub ShowTablesRectsType: c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiStackLevelInfo {
    pub ID: ImGuiID,
    pub QueryFrameCount: ImS8,
    pub QuerySuccess: bool,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Desc: [c_char; 57usize],
}
impl Default for ImGuiStackLevelInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ImGuiStackLevelInfo {
    #[inline]
    pub fn DataType(&self) -> ImGuiDataType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_DataType(&mut self, val: ImGuiDataType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DataType: ImGuiDataType) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let DataType: u32 = unsafe { ::core::mem::transmute(DataType) };
            DataType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiStackLevelInfo {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiStackLevelInfo,
}
impl Default for ImVector_ImGuiStackLevelInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiStackTool {
    pub LastActiveFrame: c_int,
    pub StackLevel: c_int,
    pub QueryId: ImGuiID,
    pub Results: ImVector_ImGuiStackLevelInfo,
    pub CopyToClipboardOnCtrlC: bool,
    pub CopyToClipboardLastTime: f32,
}
impl Default for ImGuiStackTool {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ImGuiContextHookCallback =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ImGuiContext, hook: *mut ImGuiContextHook)>;
pub const ImGuiContextHookType_NewFramePre: ImGuiContextHookType = 0;
pub const ImGuiContextHookType_NewFramePost: ImGuiContextHookType = 1;
pub const ImGuiContextHookType_EndFramePre: ImGuiContextHookType = 2;
pub const ImGuiContextHookType_EndFramePost: ImGuiContextHookType = 3;
pub const ImGuiContextHookType_RenderPre: ImGuiContextHookType = 4;
pub const ImGuiContextHookType_RenderPost: ImGuiContextHookType = 5;
pub const ImGuiContextHookType_Shutdown: ImGuiContextHookType = 6;
pub const ImGuiContextHookType_PendingRemoval_: ImGuiContextHookType = 7;
pub type ImGuiContextHookType = c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiContextHook {
    pub HookId: ImGuiID,
    pub Type: ImGuiContextHookType,
    pub Owner: ImGuiID,
    pub Callback: ImGuiContextHookCallback,
    pub UserData: *mut c_void,
}
impl Default for ImGuiContextHook {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiInputEvent {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiInputEvent,
}
impl Default for ImVector_ImGuiInputEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiWindowStackData {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiWindowStackData,
}
impl Default for ImVector_ImGuiWindowStackData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiColorMod {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiColorMod,
}
impl Default for ImVector_ImGuiColorMod {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiStyleMod {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiStyleMod,
}
impl Default for ImVector_ImGuiStyleMod {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiID {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiID,
}
impl Default for ImVector_ImGuiID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiItemFlags {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiItemFlags,
}
impl Default for ImVector_ImGuiItemFlags {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiGroupData {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiGroupData,
}
impl Default for ImVector_ImGuiGroupData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiPopupData {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiPopupData,
}
impl Default for ImVector_ImGuiPopupData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiViewportPPtr {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut *mut ImGuiViewportP,
}
impl Default for ImVector_ImGuiViewportPPtr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_unsigned_char {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut c_uchar,
}
impl Default for ImVector_unsigned_char {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiListClipperData {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiListClipperData,
}
impl Default for ImVector_ImGuiListClipperData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiTableTempData {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiTableTempData,
}
impl Default for ImVector_ImGuiTableTempData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiTable {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiTable,
}
impl Default for ImVector_ImGuiTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImPool_ImGuiTable {
    pub Buf: ImVector_ImGuiTable,
    pub Map: ImGuiStorage,
    pub FreeIdx: ImPoolIdx,
    pub AliveCount: ImPoolIdx,
}
impl Default for ImPool_ImGuiTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiTabBar {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiTabBar,
}
impl Default for ImVector_ImGuiTabBar {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImPool_ImGuiTabBar {
    pub Buf: ImVector_ImGuiTabBar,
    pub Map: ImGuiStorage,
    pub FreeIdx: ImPoolIdx,
    pub AliveCount: ImPoolIdx,
}
impl Default for ImPool_ImGuiTabBar {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiPtrOrIndex {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiPtrOrIndex,
}
impl Default for ImVector_ImGuiPtrOrIndex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiShrinkWidthItem {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiShrinkWidthItem,
}
impl Default for ImVector_ImGuiShrinkWidthItem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiSettingsHandler {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiSettingsHandler,
}
impl Default for ImVector_ImGuiSettingsHandler {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImChunkStream_ImGuiWindowSettings {
    pub Buf: ImVector_char,
}
impl Default for ImChunkStream_ImGuiWindowSettings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImChunkStream_ImGuiTableSettings {
    pub Buf: ImVector_char,
}
impl Default for ImChunkStream_ImGuiTableSettings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiContextHook {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiContextHook,
}
impl Default for ImVector_ImGuiContextHook {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiContext {
    pub Initialized: bool,
    pub FontAtlasOwnedByContext: bool,
    pub IO: ImGuiIO,
    pub PlatformIO: ImGuiPlatformIO,
    pub InputEventsQueue: ImVector_ImGuiInputEvent,
    pub InputEventsTrail: ImVector_ImGuiInputEvent,
    pub Style: ImGuiStyle,
    pub ConfigFlagsCurrFrame: ImGuiConfigFlags,
    pub ConfigFlagsLastFrame: ImGuiConfigFlags,
    pub Font: *mut ImFont,
    pub FontSize: f32,
    pub FontBaseSize: f32,
    pub DrawListSharedData: ImDrawListSharedData,
    pub Time: f64,
    pub FrameCount: c_int,
    pub FrameCountEnded: c_int,
    pub FrameCountPlatformEnded: c_int,
    pub FrameCountRendered: c_int,
    pub WithinFrameScope: bool,
    pub WithinFrameScopeWithImplicitWindow: bool,
    pub WithinEndChild: bool,
    pub GcCompactAll: bool,
    pub TestEngineHookItems: bool,
    pub TestEngine: *mut c_void,
    pub Windows: ImVector_ImGuiWindowPtr,
    pub WindowsFocusOrder: ImVector_ImGuiWindowPtr,
    pub WindowsTempSortBuffer: ImVector_ImGuiWindowPtr,
    pub CurrentWindowStack: ImVector_ImGuiWindowStackData,
    pub WindowsById: ImGuiStorage,
    pub WindowsActiveCount: c_int,
    pub WindowsHoverPadding: ImVec2,
    pub CurrentWindow: *mut ImGuiWindow,
    pub HoveredWindow: *mut ImGuiWindow,
    pub HoveredWindowUnderMovingWindow: *mut ImGuiWindow,
    pub MovingWindow: *mut ImGuiWindow,
    pub WheelingWindow: *mut ImGuiWindow,
    pub WheelingWindowRefMousePos: ImVec2,
    pub WheelingWindowStartFrame: c_int,
    pub WheelingWindowReleaseTimer: f32,
    pub WheelingWindowWheelRemainder: ImVec2,
    pub WheelingAxisAvg: ImVec2,
    pub DebugHookIdInfo: ImGuiID,
    pub HoveredId: ImGuiID,
    pub HoveredIdPreviousFrame: ImGuiID,
    pub HoveredIdAllowOverlap: bool,
    pub HoveredIdDisabled: bool,
    pub HoveredIdTimer: f32,
    pub HoveredIdNotActiveTimer: f32,
    pub ActiveId: ImGuiID,
    pub ActiveIdIsAlive: ImGuiID,
    pub ActiveIdTimer: f32,
    pub ActiveIdIsJustActivated: bool,
    pub ActiveIdAllowOverlap: bool,
    pub ActiveIdNoClearOnFocusLoss: bool,
    pub ActiveIdHasBeenPressedBefore: bool,
    pub ActiveIdHasBeenEditedBefore: bool,
    pub ActiveIdHasBeenEditedThisFrame: bool,
    pub ActiveIdClickOffset: ImVec2,
    pub ActiveIdWindow: *mut ImGuiWindow,
    pub ActiveIdSource: ImGuiInputSource,
    pub ActiveIdMouseButton: c_int,
    pub ActiveIdPreviousFrame: ImGuiID,
    pub ActiveIdPreviousFrameIsAlive: bool,
    pub ActiveIdPreviousFrameHasBeenEditedBefore: bool,
    pub ActiveIdPreviousFrameWindow: *mut ImGuiWindow,
    pub LastActiveId: ImGuiID,
    pub LastActiveIdTimer: f32,
    pub KeysOwnerData: [ImGuiKeyOwnerData; 140usize],
    pub KeysRoutingTable: ImGuiKeyRoutingTable,
    pub ActiveIdUsingNavDirMask: ImU32,
    pub ActiveIdUsingAllKeyboardKeys: bool,
    pub ActiveIdUsingNavInputMask: ImU32,
    pub CurrentFocusScopeId: ImGuiID,
    pub CurrentItemFlags: ImGuiItemFlags,
    pub DebugLocateId: ImGuiID,
    pub NextItemData: ImGuiNextItemData,
    pub LastItemData: ImGuiLastItemData,
    pub NextWindowData: ImGuiNextWindowData,
    pub ColorStack: ImVector_ImGuiColorMod,
    pub StyleVarStack: ImVector_ImGuiStyleMod,
    pub FontStack: ImVector_ImFontPtr,
    pub FocusScopeStack: ImVector_ImGuiID,
    pub ItemFlagsStack: ImVector_ImGuiItemFlags,
    pub GroupStack: ImVector_ImGuiGroupData,
    pub OpenPopupStack: ImVector_ImGuiPopupData,
    pub BeginPopupStack: ImVector_ImGuiPopupData,
    pub BeginMenuCount: c_int,
    pub Viewports: ImVector_ImGuiViewportPPtr,
    pub CurrentDpiScale: f32,
    pub CurrentViewport: *mut ImGuiViewportP,
    pub MouseViewport: *mut ImGuiViewportP,
    pub MouseLastHoveredViewport: *mut ImGuiViewportP,
    pub PlatformLastFocusedViewportId: ImGuiID,
    pub FallbackMonitor: ImGuiPlatformMonitor,
    pub ViewportFrontMostStampCount: c_int,
    pub NavWindow: *mut ImGuiWindow,
    pub NavId: ImGuiID,
    pub NavFocusScopeId: ImGuiID,
    pub NavActivateId: ImGuiID,
    pub NavActivateDownId: ImGuiID,
    pub NavActivatePressedId: ImGuiID,
    pub NavActivateInputId: ImGuiID,
    pub NavActivateFlags: ImGuiActivateFlags,
    pub NavJustMovedToId: ImGuiID,
    pub NavJustMovedToFocusScopeId: ImGuiID,
    pub NavJustMovedToKeyMods: ImGuiKeyChord,
    pub NavNextActivateId: ImGuiID,
    pub NavNextActivateFlags: ImGuiActivateFlags,
    pub NavInputSource: ImGuiInputSource,
    pub NavLayer: ImGuiNavLayer,
    pub NavIdIsAlive: bool,
    pub NavMousePosDirty: bool,
    pub NavDisableHighlight: bool,
    pub NavDisableMouseHover: bool,
    pub NavAnyRequest: bool,
    pub NavInitRequest: bool,
    pub NavInitRequestFromMove: bool,
    pub NavInitResultId: ImGuiID,
    pub NavInitResultRectRel: ImRect,
    pub NavMoveSubmitted: bool,
    pub NavMoveScoringItems: bool,
    pub NavMoveForwardToNextFrame: bool,
    pub NavMoveFlags: ImGuiNavMoveFlags,
    pub NavMoveScrollFlags: ImGuiScrollFlags,
    pub NavMoveKeyMods: ImGuiKeyChord,
    pub NavMoveDir: ImGuiDir,
    pub NavMoveDirForDebug: ImGuiDir,
    pub NavMoveClipDir: ImGuiDir,
    pub NavScoringRect: ImRect,
    pub NavScoringNoClipRect: ImRect,
    pub NavScoringDebugCount: c_int,
    pub NavTabbingDir: c_int,
    pub NavTabbingCounter: c_int,
    pub NavMoveResultLocal: ImGuiNavItemData,
    pub NavMoveResultLocalVisible: ImGuiNavItemData,
    pub NavMoveResultOther: ImGuiNavItemData,
    pub NavTabbingResultFirst: ImGuiNavItemData,
    pub ConfigNavWindowingKeyNext: ImGuiKeyChord,
    pub ConfigNavWindowingKeyPrev: ImGuiKeyChord,
    pub NavWindowingTarget: *mut ImGuiWindow,
    pub NavWindowingTargetAnim: *mut ImGuiWindow,
    pub NavWindowingListWindow: *mut ImGuiWindow,
    pub NavWindowingTimer: f32,
    pub NavWindowingHighlightAlpha: f32,
    pub NavWindowingToggleLayer: bool,
    pub NavWindowingAccumDeltaPos: ImVec2,
    pub NavWindowingAccumDeltaSize: ImVec2,
    pub DimBgRatio: f32,
    pub MouseCursor: ImGuiMouseCursor,
    pub DragDropActive: bool,
    pub DragDropWithinSource: bool,
    pub DragDropWithinTarget: bool,
    pub DragDropSourceFlags: ImGuiDragDropFlags,
    pub DragDropSourceFrameCount: c_int,
    pub DragDropMouseButton: c_int,
    pub DragDropPayload: ImGuiPayload,
    pub DragDropTargetRect: ImRect,
    pub DragDropTargetId: ImGuiID,
    pub DragDropAcceptFlags: ImGuiDragDropFlags,
    pub DragDropAcceptIdCurrRectSurface: f32,
    pub DragDropAcceptIdCurr: ImGuiID,
    pub DragDropAcceptIdPrev: ImGuiID,
    pub DragDropAcceptFrameCount: c_int,
    pub DragDropHoldJustPressedId: ImGuiID,
    pub DragDropPayloadBufHeap: ImVector_unsigned_char,
    pub DragDropPayloadBufLocal: [c_uchar; 16usize],
    pub ClipperTempDataStacked: c_int,
    pub ClipperTempData: ImVector_ImGuiListClipperData,
    pub CurrentTable: *mut ImGuiTable,
    pub TablesTempDataStacked: c_int,
    pub TablesTempData: ImVector_ImGuiTableTempData,
    pub Tables: ImPool_ImGuiTable,
    pub TablesLastTimeActive: ImVector_float,
    pub DrawChannelsTempMergeBuffer: ImVector_ImDrawChannel,
    pub CurrentTabBar: *mut ImGuiTabBar,
    pub TabBars: ImPool_ImGuiTabBar,
    pub CurrentTabBarStack: ImVector_ImGuiPtrOrIndex,
    pub ShrinkWidthBuffer: ImVector_ImGuiShrinkWidthItem,
    pub HoverDelayId: ImGuiID,
    pub HoverDelayIdPreviousFrame: ImGuiID,
    pub HoverDelayTimer: f32,
    pub HoverDelayClearTimer: f32,
    pub MouseLastValidPos: ImVec2,
    pub InputTextState: ImGuiInputTextState,
    pub InputTextPasswordFont: ImFont,
    pub TempInputId: ImGuiID,
    pub ColorEditOptions: ImGuiColorEditFlags,
    pub ColorEditLastHue: f32,
    pub ColorEditLastSat: f32,
    pub ColorEditLastColor: ImU32,
    pub ColorPickerRef: ImVec4,
    pub ComboPreviewData: ImGuiComboPreviewData,
    pub SliderGrabClickOffset: f32,
    pub SliderCurrentAccum: f32,
    pub SliderCurrentAccumDirty: bool,
    pub DragCurrentAccumDirty: bool,
    pub DragCurrentAccum: f32,
    pub DragSpeedDefaultRatio: f32,
    pub ScrollbarClickDeltaToGrabCenter: f32,
    pub DisabledAlphaBackup: f32,
    pub DisabledStackSize: c_short,
    pub TooltipOverrideCount: c_short,
    pub ClipboardHandlerData: ImVector_char,
    pub MenusIdSubmittedThisFrame: ImVector_ImGuiID,
    pub PlatformImeData: ImGuiPlatformImeData,
    pub PlatformImeDataPrev: ImGuiPlatformImeData,
    pub PlatformImeViewport: ImGuiID,
    pub PlatformLocaleDecimalPoint: c_char,
    pub DockContext: ImGuiDockContext,
    pub SettingsLoaded: bool,
    pub SettingsDirtyTimer: f32,
    pub SettingsIniData: ImGuiTextBuffer,
    pub SettingsHandlers: ImVector_ImGuiSettingsHandler,
    pub SettingsWindows: ImChunkStream_ImGuiWindowSettings,
    pub SettingsTables: ImChunkStream_ImGuiTableSettings,
    pub Hooks: ImVector_ImGuiContextHook,
    pub HookIdNext: ImGuiID,
    pub LocalizationTable: [*const c_char; 8usize],
    pub LogEnabled: bool,
    pub LogType: ImGuiLogType,
    pub LogFile: ImFileHandle,
    pub LogBuffer: ImGuiTextBuffer,
    pub LogNextPrefix: *const c_char,
    pub LogNextSuffix: *const c_char,
    pub LogLinePosY: f32,
    pub LogLineFirstItem: bool,
    pub LogDepthRef: c_int,
    pub LogDepthToExpand: c_int,
    pub LogDepthToExpandDefault: c_int,
    pub DebugLogFlags: ImGuiDebugLogFlags,
    pub DebugLogBuf: ImGuiTextBuffer,
    pub DebugLogIndex: ImGuiTextIndex,
    pub DebugLocateFrames: ImU8,
    pub DebugItemPickerActive: bool,
    pub DebugItemPickerMouseButton: ImU8,
    pub DebugItemPickerBreakId: ImGuiID,
    pub DebugMetricsConfig: ImGuiMetricsConfig,
    pub DebugStackTool: ImGuiStackTool,
    pub DebugHoveredDockNode: *mut ImGuiDockNode,
    pub FramerateSecPerFrame: [f32; 60usize],
    pub FramerateSecPerFrameIdx: c_int,
    pub FramerateSecPerFrameCount: c_int,
    pub FramerateSecPerFrameAccum: f32,
    pub WantCaptureMouseNextFrame: c_int,
    pub WantCaptureKeyboardNextFrame: c_int,
    pub WantTextInputNextFrame: c_int,
    pub TempBuffer: ImVector_char,
}
impl Default for ImGuiContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiWindowTempData {
    pub CursorPos: ImVec2,
    pub CursorPosPrevLine: ImVec2,
    pub CursorStartPos: ImVec2,
    pub CursorMaxPos: ImVec2,
    pub IdealMaxPos: ImVec2,
    pub CurrLineSize: ImVec2,
    pub PrevLineSize: ImVec2,
    pub CurrLineTextBaseOffset: f32,
    pub PrevLineTextBaseOffset: f32,
    pub IsSameLine: bool,
    pub IsSetPos: bool,
    pub Indent: ImVec1,
    pub ColumnsOffset: ImVec1,
    pub GroupOffset: ImVec1,
    pub CursorStartPosLossyness: ImVec2,
    pub NavLayerCurrent: ImGuiNavLayer,
    pub NavLayersActiveMask: c_short,
    pub NavLayersActiveMaskNext: c_short,
    pub NavHideHighlightOneFrame: bool,
    pub NavHasScroll: bool,
    pub MenuBarAppending: bool,
    pub MenuBarOffset: ImVec2,
    pub MenuColumns: ImGuiMenuColumns,
    pub TreeDepth: c_int,
    pub TreeJumpToParentOnPopMask: ImU32,
    pub ChildWindows: ImVector_ImGuiWindowPtr,
    pub StateStorage: *mut ImGuiStorage,
    pub CurrentColumns: *mut ImGuiOldColumns,
    pub CurrentTableIdx: c_int,
    pub LayoutType: ImGuiLayoutType,
    pub ParentLayoutType: ImGuiLayoutType,
    pub ItemWidth: f32,
    pub TextWrapPos: f32,
    pub ItemWidthStack: ImVector_float,
    pub TextWrapPosStack: ImVector_float,
}
impl Default for ImGuiWindowTempData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiOldColumns {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiOldColumns,
}
impl Default for ImVector_ImGuiOldColumns {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiWindow {
    pub Name: *mut c_char,
    pub ID: ImGuiID,
    pub Flags: ImGuiWindowFlags,
    pub FlagsPreviousFrame: ImGuiWindowFlags,
    pub WindowClass: ImGuiWindowClass,
    pub Viewport: *mut ImGuiViewportP,
    pub ViewportId: ImGuiID,
    pub ViewportPos: ImVec2,
    pub ViewportAllowPlatformMonitorExtend: c_int,
    pub Pos: ImVec2,
    pub Size: ImVec2,
    pub SizeFull: ImVec2,
    pub ContentSize: ImVec2,
    pub ContentSizeIdeal: ImVec2,
    pub ContentSizeExplicit: ImVec2,
    pub WindowPadding: ImVec2,
    pub WindowRounding: f32,
    pub WindowBorderSize: f32,
    pub DecoOuterSizeX1: f32,
    pub DecoOuterSizeY1: f32,
    pub DecoOuterSizeX2: f32,
    pub DecoOuterSizeY2: f32,
    pub DecoInnerSizeX1: f32,
    pub DecoInnerSizeY1: f32,
    pub NameBufLen: c_int,
    pub MoveId: ImGuiID,
    pub TabId: ImGuiID,
    pub ChildId: ImGuiID,
    pub Scroll: ImVec2,
    pub ScrollMax: ImVec2,
    pub ScrollTarget: ImVec2,
    pub ScrollTargetCenterRatio: ImVec2,
    pub ScrollTargetEdgeSnapDist: ImVec2,
    pub ScrollbarSizes: ImVec2,
    pub ScrollbarX: bool,
    pub ScrollbarY: bool,
    pub ViewportOwned: bool,
    pub Active: bool,
    pub WasActive: bool,
    pub WriteAccessed: bool,
    pub Collapsed: bool,
    pub WantCollapseToggle: bool,
    pub SkipItems: bool,
    pub Appearing: bool,
    pub Hidden: bool,
    pub IsFallbackWindow: bool,
    pub IsExplicitChild: bool,
    pub HasCloseButton: bool,
    pub ResizeBorderHeld: c_schar,
    pub BeginCount: c_short,
    pub BeginCountPreviousFrame: c_short,
    pub BeginOrderWithinParent: c_short,
    pub BeginOrderWithinContext: c_short,
    pub FocusOrder: c_short,
    pub PopupId: ImGuiID,
    pub AutoFitFramesX: ImS8,
    pub AutoFitFramesY: ImS8,
    pub AutoFitChildAxises: ImS8,
    pub AutoFitOnlyGrows: bool,
    pub AutoPosLastDirection: ImGuiDir,
    pub HiddenFramesCanSkipItems: ImS8,
    pub HiddenFramesCannotSkipItems: ImS8,
    pub HiddenFramesForRenderOnly: ImS8,
    pub DisableInputsFrames: ImS8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub SetWindowPosVal: ImVec2,
    pub SetWindowPosPivot: ImVec2,
    pub IDStack: ImVector_ImGuiID,
    pub DC: ImGuiWindowTempData,
    pub OuterRectClipped: ImRect,
    pub InnerRect: ImRect,
    pub InnerClipRect: ImRect,
    pub WorkRect: ImRect,
    pub ParentWorkRect: ImRect,
    pub ClipRect: ImRect,
    pub ContentRegionRect: ImRect,
    pub HitTestHoleSize: ImVec2ih,
    pub HitTestHoleOffset: ImVec2ih,
    pub LastFrameActive: c_int,
    pub LastFrameJustFocused: c_int,
    pub LastTimeActive: f32,
    pub ItemWidthDefault: f32,
    pub StateStorage: ImGuiStorage,
    pub ColumnsStorage: ImVector_ImGuiOldColumns,
    pub FontWindowScale: f32,
    pub FontDpiScale: f32,
    pub SettingsOffset: c_int,
    pub DrawList: *mut ImDrawList,
    pub DrawListInst: ImDrawList,
    pub ParentWindow: *mut ImGuiWindow,
    pub ParentWindowInBeginStack: *mut ImGuiWindow,
    pub RootWindow: *mut ImGuiWindow,
    pub RootWindowPopupTree: *mut ImGuiWindow,
    pub RootWindowDockTree: *mut ImGuiWindow,
    pub RootWindowForTitleBarHighlight: *mut ImGuiWindow,
    pub RootWindowForNav: *mut ImGuiWindow,
    pub NavLastChildNavWindow: *mut ImGuiWindow,
    pub NavLastIds: [ImGuiID; 2usize],
    pub NavRectRel: [ImRect; 2usize],
    pub NavRootFocusScopeId: ImGuiID,
    pub MemoryDrawListIdxCapacity: c_int,
    pub MemoryDrawListVtxCapacity: c_int,
    pub MemoryCompacted: bool,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub DockOrder: c_short,
    pub DockStyle: ImGuiWindowDockStyle,
    pub DockNode: *mut ImGuiDockNode,
    pub DockNodeAsHost: *mut ImGuiDockNode,
    pub DockId: ImGuiID,
    pub DockTabItemStatusFlags: ImGuiItemStatusFlags,
    pub DockTabItemRect: ImRect,
}
impl Default for ImGuiWindow {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ImGuiWindow {
    #[inline]
    pub fn SetWindowPosAllowFlags(&self) -> ImGuiCond {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SetWindowPosAllowFlags(&mut self, val: ImGuiCond) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn SetWindowSizeAllowFlags(&self) -> ImGuiCond {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SetWindowSizeAllowFlags(&mut self, val: ImGuiCond) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn SetWindowCollapsedAllowFlags(&self) -> ImGuiCond {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SetWindowCollapsedAllowFlags(&mut self, val: ImGuiCond) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn SetWindowDockAllowFlags(&self) -> ImGuiCond {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SetWindowDockAllowFlags(&mut self, val: ImGuiCond) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SetWindowPosAllowFlags: ImGuiCond,
        SetWindowSizeAllowFlags: ImGuiCond,
        SetWindowCollapsedAllowFlags: ImGuiCond,
        SetWindowDockAllowFlags: ImGuiCond,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let SetWindowPosAllowFlags: u32 = unsafe { ::core::mem::transmute(SetWindowPosAllowFlags) };
            SetWindowPosAllowFlags as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let SetWindowSizeAllowFlags: u32 = unsafe { ::core::mem::transmute(SetWindowSizeAllowFlags) };
            SetWindowSizeAllowFlags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let SetWindowCollapsedAllowFlags: u32 = unsafe { ::core::mem::transmute(SetWindowCollapsedAllowFlags) };
            SetWindowCollapsedAllowFlags as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let SetWindowDockAllowFlags: u32 = unsafe { ::core::mem::transmute(SetWindowDockAllowFlags) };
            SetWindowDockAllowFlags as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn DockIsActive(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DockIsActive(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DockNodeIsVisible(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DockNodeIsVisible(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DockTabIsVisible(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DockTabIsVisible(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DockTabWantClose(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DockTabWantClose(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        DockIsActive: bool,
        DockNodeIsVisible: bool,
        DockTabIsVisible: bool,
        DockTabWantClose: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DockIsActive: u8 = unsafe { ::core::mem::transmute(DockIsActive) };
            DockIsActive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DockNodeIsVisible: u8 = unsafe { ::core::mem::transmute(DockNodeIsVisible) };
            DockNodeIsVisible as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DockTabIsVisible: u8 = unsafe { ::core::mem::transmute(DockTabIsVisible) };
            DockTabIsVisible as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DockTabWantClose: u8 = unsafe { ::core::mem::transmute(DockTabWantClose) };
            DockTabWantClose as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const ImGuiTabBarFlags_DockNode: ImGuiTabBarFlagsPrivate_ = 1048576;
pub const ImGuiTabBarFlags_IsFocused: ImGuiTabBarFlagsPrivate_ = 2097152;
pub const ImGuiTabBarFlags_SaveSettings: ImGuiTabBarFlagsPrivate_ = 4194304;
pub type ImGuiTabBarFlagsPrivate_ = c_uint;
pub const ImGuiTabItemFlags_SectionMask_: ImGuiTabItemFlagsPrivate_ = 192;
pub const ImGuiTabItemFlags_NoCloseButton: ImGuiTabItemFlagsPrivate_ = 1048576;
pub const ImGuiTabItemFlags_Button: ImGuiTabItemFlagsPrivate_ = 2097152;
pub const ImGuiTabItemFlags_Unsorted: ImGuiTabItemFlagsPrivate_ = 4194304;
pub const ImGuiTabItemFlags_Preview: ImGuiTabItemFlagsPrivate_ = 8388608;
pub type ImGuiTabItemFlagsPrivate_ = c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiTabItem {
    pub ID: ImGuiID,
    pub Flags: ImGuiTabItemFlags,
    pub Window: *mut ImGuiWindow,
    pub LastFrameVisible: c_int,
    pub LastFrameSelected: c_int,
    pub Offset: f32,
    pub Width: f32,
    pub ContentWidth: f32,
    pub RequestedWidth: f32,
    pub NameOffset: ImS32,
    pub BeginOrder: ImS16,
    pub IndexDuringLayout: ImS16,
    pub WantClose: bool,
}
impl Default for ImGuiTabItem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiTabItem {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiTabItem,
}
impl Default for ImVector_ImGuiTabItem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiTabBar {
    pub Tabs: ImVector_ImGuiTabItem,
    pub Flags: ImGuiTabBarFlags,
    pub ID: ImGuiID,
    pub SelectedTabId: ImGuiID,
    pub NextSelectedTabId: ImGuiID,
    pub VisibleTabId: ImGuiID,
    pub CurrFrameVisible: c_int,
    pub PrevFrameVisible: c_int,
    pub BarRect: ImRect,
    pub CurrTabsContentsHeight: f32,
    pub PrevTabsContentsHeight: f32,
    pub WidthAllTabs: f32,
    pub WidthAllTabsIdeal: f32,
    pub ScrollingAnim: f32,
    pub ScrollingTarget: f32,
    pub ScrollingTargetDistToVisibility: f32,
    pub ScrollingSpeed: f32,
    pub ScrollingRectMinX: f32,
    pub ScrollingRectMaxX: f32,
    pub ReorderRequestTabId: ImGuiID,
    pub ReorderRequestOffset: ImS16,
    pub BeginCount: ImS8,
    pub WantLayout: bool,
    pub VisibleTabWasSubmitted: bool,
    pub TabsAddedNew: bool,
    pub TabsActiveCount: ImS16,
    pub LastTabItemIdx: ImS16,
    pub ItemSpacingY: f32,
    pub FramePadding: ImVec2,
    pub BackupCursorPos: ImVec2,
    pub TabsNames: ImGuiTextBuffer,
}
impl Default for ImGuiTabBar {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ImGuiTableColumnIdx = ImS8;
pub type ImGuiTableDrawChannelIdx = ImU8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiTableColumn {
    pub Flags: ImGuiTableColumnFlags,
    pub WidthGiven: f32,
    pub MinX: f32,
    pub MaxX: f32,
    pub WidthRequest: f32,
    pub WidthAuto: f32,
    pub StretchWeight: f32,
    pub InitStretchWeightOrWidth: f32,
    pub ClipRect: ImRect,
    pub UserID: ImGuiID,
    pub WorkMinX: f32,
    pub WorkMaxX: f32,
    pub ItemWidth: f32,
    pub ContentMaxXFrozen: f32,
    pub ContentMaxXUnfrozen: f32,
    pub ContentMaxXHeadersUsed: f32,
    pub ContentMaxXHeadersIdeal: f32,
    pub NameOffset: ImS16,
    pub DisplayOrder: ImGuiTableColumnIdx,
    pub IndexWithinEnabledSet: ImGuiTableColumnIdx,
    pub PrevEnabledColumn: ImGuiTableColumnIdx,
    pub NextEnabledColumn: ImGuiTableColumnIdx,
    pub SortOrder: ImGuiTableColumnIdx,
    pub DrawChannelCurrent: ImGuiTableDrawChannelIdx,
    pub DrawChannelFrozen: ImGuiTableDrawChannelIdx,
    pub DrawChannelUnfrozen: ImGuiTableDrawChannelIdx,
    pub IsEnabled: bool,
    pub IsUserEnabled: bool,
    pub IsUserEnabledNextFrame: bool,
    pub IsVisibleX: bool,
    pub IsVisibleY: bool,
    pub IsRequestOutput: bool,
    pub IsSkipItems: bool,
    pub IsPreserveWidthAuto: bool,
    pub NavLayerCurrent: ImS8,
    pub AutoFitQueue: ImU8,
    pub CannotSkipItemsQueue: ImU8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub SortDirectionsAvailList: ImU8,
}
impl ImGuiTableColumn {
    #[inline]
    pub fn SortDirection(&self) -> ImU8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_SortDirection(&mut self, val: ImU8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SortDirectionsAvailCount(&self) -> ImU8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_SortDirectionsAvailCount(&mut self, val: ImU8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SortDirectionsAvailMask(&self) -> ImU8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_SortDirectionsAvailMask(&mut self, val: ImU8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SortDirection: ImU8,
        SortDirectionsAvailCount: ImU8,
        SortDirectionsAvailMask: ImU8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let SortDirection: u8 = unsafe { ::core::mem::transmute(SortDirection) };
            SortDirection as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let SortDirectionsAvailCount: u8 = unsafe { ::core::mem::transmute(SortDirectionsAvailCount) };
            SortDirectionsAvailCount as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let SortDirectionsAvailMask: u8 = unsafe { ::core::mem::transmute(SortDirectionsAvailMask) };
            SortDirectionsAvailMask as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImGuiTableCellData {
    pub BgColor: ImU32,
    pub Column: ImGuiTableColumnIdx,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiTableInstanceData {
    pub LastOuterHeight: f32,
    pub LastFirstRowHeight: f32,
    pub LastFrozenHeight: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImSpan_ImGuiTableColumn {
    pub Data: *mut ImGuiTableColumn,
    pub DataEnd: *mut ImGuiTableColumn,
}
impl Default for ImSpan_ImGuiTableColumn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImSpan_ImGuiTableColumnIdx {
    pub Data: *mut ImGuiTableColumnIdx,
    pub DataEnd: *mut ImGuiTableColumnIdx,
}
impl Default for ImSpan_ImGuiTableColumnIdx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImSpan_ImGuiTableCellData {
    pub Data: *mut ImGuiTableCellData,
    pub DataEnd: *mut ImGuiTableCellData,
}
impl Default for ImSpan_ImGuiTableCellData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiTableInstanceData {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiTableInstanceData,
}
impl Default for ImVector_ImGuiTableInstanceData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImVector_ImGuiTableColumnSortSpecs {
    pub Size: c_int,
    pub Capacity: c_int,
    pub Data: *mut ImGuiTableColumnSortSpecs,
}
impl Default for ImVector_ImGuiTableColumnSortSpecs {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiTable {
    pub ID: ImGuiID,
    pub Flags: ImGuiTableFlags,
    pub RawData: *mut c_void,
    pub TempData: *mut ImGuiTableTempData,
    pub Columns: ImSpan_ImGuiTableColumn,
    pub DisplayOrderToIndex: ImSpan_ImGuiTableColumnIdx,
    pub RowCellData: ImSpan_ImGuiTableCellData,
    pub EnabledMaskByDisplayOrder: ImU64,
    pub EnabledMaskByIndex: ImU64,
    pub VisibleMaskByIndex: ImU64,
    pub RequestOutputMaskByIndex: ImU64,
    pub SettingsLoadedFlags: ImGuiTableFlags,
    pub SettingsOffset: c_int,
    pub LastFrameActive: c_int,
    pub ColumnsCount: c_int,
    pub CurrentRow: c_int,
    pub CurrentColumn: c_int,
    pub InstanceCurrent: ImS16,
    pub InstanceInteracted: ImS16,
    pub RowPosY1: f32,
    pub RowPosY2: f32,
    pub RowMinHeight: f32,
    pub RowTextBaseline: f32,
    pub RowIndentOffsetX: f32,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub RowBgColorCounter: c_int,
    pub RowBgColor: [ImU32; 2usize],
    pub BorderColorStrong: ImU32,
    pub BorderColorLight: ImU32,
    pub BorderX1: f32,
    pub BorderX2: f32,
    pub HostIndentX: f32,
    pub MinColumnWidth: f32,
    pub OuterPaddingX: f32,
    pub CellPaddingX: f32,
    pub CellPaddingY: f32,
    pub CellSpacingX1: f32,
    pub CellSpacingX2: f32,
    pub InnerWidth: f32,
    pub ColumnsGivenWidth: f32,
    pub ColumnsAutoFitWidth: f32,
    pub ColumnsStretchSumWeights: f32,
    pub ResizedColumnNextWidth: f32,
    pub ResizeLockMinContentsX2: f32,
    pub RefScale: f32,
    pub OuterRect: ImRect,
    pub InnerRect: ImRect,
    pub WorkRect: ImRect,
    pub InnerClipRect: ImRect,
    pub BgClipRect: ImRect,
    pub Bg0ClipRectForDrawCmd: ImRect,
    pub Bg2ClipRectForDrawCmd: ImRect,
    pub HostClipRect: ImRect,
    pub HostBackupInnerClipRect: ImRect,
    pub OuterWindow: *mut ImGuiWindow,
    pub InnerWindow: *mut ImGuiWindow,
    pub ColumnsNames: ImGuiTextBuffer,
    pub DrawSplitter: *mut ImDrawListSplitter,
    pub InstanceDataFirst: ImGuiTableInstanceData,
    pub InstanceDataExtra: ImVector_ImGuiTableInstanceData,
    pub SortSpecsSingle: ImGuiTableColumnSortSpecs,
    pub SortSpecsMulti: ImVector_ImGuiTableColumnSortSpecs,
    pub SortSpecs: ImGuiTableSortSpecs,
    pub SortSpecsCount: ImGuiTableColumnIdx,
    pub ColumnsEnabledCount: ImGuiTableColumnIdx,
    pub ColumnsEnabledFixedCount: ImGuiTableColumnIdx,
    pub DeclColumnsCount: ImGuiTableColumnIdx,
    pub HoveredColumnBody: ImGuiTableColumnIdx,
    pub HoveredColumnBorder: ImGuiTableColumnIdx,
    pub AutoFitSingleColumn: ImGuiTableColumnIdx,
    pub ResizedColumn: ImGuiTableColumnIdx,
    pub LastResizedColumn: ImGuiTableColumnIdx,
    pub HeldHeaderColumn: ImGuiTableColumnIdx,
    pub ReorderColumn: ImGuiTableColumnIdx,
    pub ReorderColumnDir: ImGuiTableColumnIdx,
    pub LeftMostEnabledColumn: ImGuiTableColumnIdx,
    pub RightMostEnabledColumn: ImGuiTableColumnIdx,
    pub LeftMostStretchedColumn: ImGuiTableColumnIdx,
    pub RightMostStretchedColumn: ImGuiTableColumnIdx,
    pub ContextPopupColumn: ImGuiTableColumnIdx,
    pub FreezeRowsRequest: ImGuiTableColumnIdx,
    pub FreezeRowsCount: ImGuiTableColumnIdx,
    pub FreezeColumnsRequest: ImGuiTableColumnIdx,
    pub FreezeColumnsCount: ImGuiTableColumnIdx,
    pub RowCellDataCurrent: ImGuiTableColumnIdx,
    pub DummyDrawChannel: ImGuiTableDrawChannelIdx,
    pub Bg2DrawChannelCurrent: ImGuiTableDrawChannelIdx,
    pub Bg2DrawChannelUnfrozen: ImGuiTableDrawChannelIdx,
    pub IsLayoutLocked: bool,
    pub IsInsideRow: bool,
    pub IsInitializing: bool,
    pub IsSortSpecsDirty: bool,
    pub IsUsingHeaders: bool,
    pub IsContextPopupOpen: bool,
    pub IsSettingsRequestLoad: bool,
    pub IsSettingsDirty: bool,
    pub IsDefaultDisplayOrder: bool,
    pub IsResetAllRequest: bool,
    pub IsResetDisplayOrderRequest: bool,
    pub IsUnfrozenRows: bool,
    pub IsDefaultSizingPolicy: bool,
    pub HasScrollbarYCurr: bool,
    pub HasScrollbarYPrev: bool,
    pub MemoryCompacted: bool,
    pub HostSkipItems: bool,
}
impl Default for ImGuiTable {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ImGuiTable {
    #[inline]
    pub fn RowFlags(&self) -> ImGuiTableRowFlags {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_RowFlags(&mut self, val: ImGuiTableRowFlags) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn LastRowFlags(&self) -> ImGuiTableRowFlags {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_LastRowFlags(&mut self, val: ImGuiTableRowFlags) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RowFlags: ImGuiTableRowFlags,
        LastRowFlags: ImGuiTableRowFlags,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let RowFlags: u32 = unsafe { ::core::mem::transmute(RowFlags) };
            RowFlags as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let LastRowFlags: u32 = unsafe { ::core::mem::transmute(LastRowFlags) };
            LastRowFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct ImGuiTableTempData {
    pub TableIndex: c_int,
    pub LastTimeActive: f32,
    pub UserOuterSize: ImVec2,
    pub DrawSplitter: ImDrawListSplitter,
    pub HostBackupWorkRect: ImRect,
    pub HostBackupParentWorkRect: ImRect,
    pub HostBackupPrevLineSize: ImVec2,
    pub HostBackupCurrLineSize: ImVec2,
    pub HostBackupCursorMaxPos: ImVec2,
    pub HostBackupColumnsOffset: ImVec1,
    pub HostBackupItemWidth: f32,
    pub HostBackupItemWidthStackSize: c_int,
}
impl Default for ImGuiTableTempData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiTableColumnSettings {
    pub WidthOrWeight: f32,
    pub UserID: ImGuiID,
    pub Index: ImGuiTableColumnIdx,
    pub DisplayOrder: ImGuiTableColumnIdx,
    pub SortOrder: ImGuiTableColumnIdx,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl ImGuiTableColumnSettings {
    #[inline]
    pub fn SortDirection(&self) -> ImU8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_SortDirection(&mut self, val: ImU8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn IsEnabled(&self) -> ImU8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsEnabled(&mut self, val: ImU8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsStretch(&self) -> ImU8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IsStretch(&mut self, val: ImU8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SortDirection: ImU8,
        IsEnabled: ImU8,
        IsStretch: ImU8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let SortDirection: u8 = unsafe { ::core::mem::transmute(SortDirection) };
            SortDirection as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IsEnabled: u8 = unsafe { ::core::mem::transmute(IsEnabled) };
            IsEnabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let IsStretch: u8 = unsafe { ::core::mem::transmute(IsStretch) };
            IsStretch as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ImGuiTableSettings {
    pub ID: ImGuiID,
    pub SaveFlags: ImGuiTableFlags,
    pub RefScale: f32,
    pub ColumnsCount: ImGuiTableColumnIdx,
    pub ColumnsCountMax: ImGuiTableColumnIdx,
    pub WantApply: bool,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ImFontBuilderIO {
    pub FontBuilder_Build: ::core::option::Option<unsafe extern "C" fn(atlas: *mut ImFontAtlas) -> bool>,
}
